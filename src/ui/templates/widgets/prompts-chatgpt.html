<!--
  ChatGPT Widget: Prompt Library

  BASED ON: src/ui/templates/prompts.html

  This is a copy of prompts.html adapted for ChatGPT widget context.
  Key differences from prompts.html are marked with [WIDGET CHANGE] comments.

  DIFFERENCES FROM prompts.html:
  1. Body has "widget-mode" class for CSS adjustments
  2. Sidebar includes search/filter UI (shell provides this in web app)
  3. Uses platform adapter (window.__PROMPT_PLATFORM__) for data/host communication
  4. No shell postMessage communication
  5. Init requests fullscreen mode via window.openai API
  6. Theme loaded from toolOutput, not localStorage

  When updating prompts.html, review changes and apply relevant ones here.
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Prompts</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=IBM+Plex+Sans:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/shared/themes/base.css">
  <link rel="stylesheet" href="/shared/themes/dark-1.css" id="theme-stylesheet">
  <link rel="stylesheet" href="/shared/prompt-viewer.css">
  <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.1.0/dist/markdown-it.min.js" integrity="sha384-wLhprpjsmjc/XYIcF+LpMxd8yS1gss6jhevOp6F6zhiIoFK6AmHtm4bGKtehTani" crossorigin="anonymous"></script>
  <!-- [WIDGET CHANGE] Widget-specific sidebar search styles (shell provides this in web app) -->
  <style>
    /* Widget-specific sidebar search styles */
    .sidebar-search {
      padding: var(--space-sm) var(--space-md);
      display: flex;
      flex-direction: column;
      gap: var(--space-sm);
      border-bottom: 1px solid var(--border);
    }

    .sidebar-search .search-input {
      width: 100%;
      box-sizing: border-box;
    }

    .sidebar-search .tag-picker {
      align-self: flex-start;
    }

    .sidebar-search .filter-tags {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-xs);
    }

    .sidebar-search .filter-tags:empty {
      display: none;
    }
  </style>
</head>
<!-- [WIDGET CHANGE] Added "widget-mode" class for widget-specific CSS -->
<body class="module prompts-module widget-mode">
  <aside class="sidebar">
    <!-- [WIDGET CHANGE] Search/filter UI moved here from shell (lines 65-72) -->
    <div class="sidebar-search">
      <input type="search" id="search-input" class="search-input" placeholder="Search prompts..." />
      <div class="tag-picker">
        <button class="tag-picker-btn" id="tag-picker-btn">Tags <span id="tag-count"></span></button>
        <div class="tag-picker-dropdown hidden" id="tag-picker-dropdown"></div>
      </div>
      <div class="filter-tags" id="filter-tags"></div>
    </div>
    <!-- End of widget-specific search UI -->
    <div class="sidebar-header">
      <button id="new-prompt-btn" class="btn-primary">+ New</button>
    </div>
    <div id="prompt-list" class="prompt-list">
      <!-- Populated by JavaScript -->
    </div>
  </aside>

  <main class="content">
    <div id="empty-state" class="empty-state">
      Select a prompt to view
    </div>

    <!-- Batch actions (visible when 2+ staging prompts) -->
    <div id="staging-header" class="staging-header" style="display: none;">
      <span class="staging-info">
        <span id="staging-count">0</span> prompt(s) to save
      </span>
      <div class="staging-actions">
        <button id="discard-all-btn" class="btn-secondary btn-sm">Discard All</button>
        <button id="save-all-btn" class="btn-primary btn-sm">Save All</button>
      </div>
    </div>

    <!-- Editor container (for new/edit modes) -->
    <div id="prompt-edit" class="prompt-edit" style="display: none;"></div>

    <article id="prompt-view" class="prompt-view" style="display: none;">
      <header class="prompt-header">
        <div class="prompt-header-top">
          <h1 id="prompt-slug" class="prompt-slug"></h1>
          <div class="prompt-header-controls">
            <button id="pin-toggle" class="icon-button" title="Pin prompt" aria-pressed="false">
              <span class="pin-icon"></span>
            </button>
            <button id="favorite-toggle" class="icon-button" title="Favorite prompt" aria-pressed="false">
              <span class="star-icon"></span>
            </button>
            <button id="edit-btn" class="btn-secondary btn-sm">Edit</button>
          </div>
        </div>
        <p id="prompt-description" class="prompt-description"></p>
      </header>

      <!-- Prompt Viewer Component -->
      <div class="prompt-viewer view-rendered" id="promptViewer">
        <div class="prompt-viewer-header">
          <button class="copy-btn-primary" id="copy-btn" title="Copy to clipboard">Copy</button>
          <div class="prompt-viewer-actions">
            <button class="prompt-viewer-btn active" data-view="rendered">Rendered</button>
            <button class="prompt-viewer-btn" data-view="semantic">Semantic</button>
            <button class="prompt-viewer-btn" data-view="plain">Plain</button>
            <span class="prompt-viewer-separator">|</span>
            <button class="prompt-viewer-btn" id="line-edit-toggle" title="Enable line-by-line editing">Line Edit</button>
          </div>
        </div>
        <!-- Draft expiration warning (hidden by default, shown by checkDraftExpiration) -->
        <div class="draft-expiry-warning" style="display: none;">
          <span class="warning-icon">!</span>
          <span class="warning-text">This draft will expire soon</span>
        </div>
        <div class="prompt-viewer-content" id="promptContent"></div>
        <div class="prompt-viewer-stats">
          <span class="prompt-viewer-stat">tags <span class="prompt-viewer-stat-value" id="statTags">0</span></span>
          <span class="prompt-viewer-stat">vars <span class="prompt-viewer-stat-value" id="statVars">0</span></span>
          <span class="prompt-viewer-stat">chars <span class="prompt-viewer-stat-value" id="statChars">0</span></span>
        </div>
      </div>
    </article>
  </main>

  <!-- Confirmation Modal -->
  <div id="confirm-modal" class="confirm-modal" style="display: none;">
    <div class="confirm-modal-content">
      <p id="confirm-message" class="confirm-message"></p>
      <div class="confirm-modal-actions">
        <button type="button" class="btn btn-secondary btn-sm" id="confirm-cancel">Cancel</button>
        <button type="button" class="btn btn-primary btn-sm" id="confirm-ok">OK</button>
      </div>
    </div>
  </div>

  <!-- Toast Container -->
  <div id="toast-container" class="toast-container"></div>

  <!--
    [WIDGET CHANGE] Scripts section differs from prompts.html:
    1. Loads chatgpt-adapter.js FIRST (sets up window.__PROMPT_PLATFORM__)
    2. Main script uses platform.data.* for API calls (not direct fetch)
    3. Main script uses platform.host.* for host communication (not postMessage)
    4. Init calls platform.widget.requestFullscreen()
  -->
  <script src="/js/adapters/chatgpt-adapter.js"></script>
  <script src="/js/utils.js"></script>
  <script src="/js/components/modal.js"></script>
  <script src="/js/components/toast.js"></script>
  <script src="/js/prompt-viewer.js"></script>
  <script src="/js/prompt-editor.js"></script>
  <script>
    /**
     * @typedef {Object} DraftData
     * @property {string} slug
     * @property {string} name
     * @property {string} description
     * @property {string} content
     * @property {string[]} tags
     */

    /**
     * @typedef {Object} Draft
     * @property {string} draftId - Format: "edit:{slug}" or "new:{tempId}"
     * @property {'edit'|'new'} type
     * @property {string|null} promptSlug - Slug of prompt being edited (null for new)
     * @property {DraftData} data
     * @property {number} [createdAt]
     * @property {number} [updatedAt]
     * @property {number} [expiresAt]
     */

    // Platform adapter reference
    const platform = window.__PROMPT_PLATFORM__;

    // Valid themes (static list for widget context)
    const VALID_THEMES = ['light-1', 'light-2', 'light-3', 'dark-1', 'dark-2', 'dark-3'];

    // State
    let prompts = [];
    let selectedSlug = null;
    let currentMode = 'empty'; // 'empty' | 'view' | 'edit' | 'new'
    let currentView = 'rendered';
    let lineEditEnabled = false;
    try {
      currentView = localStorage.getItem('promptViewMode') || 'rendered';
      lineEditEnabled = localStorage.getItem('lineEditEnabled') === 'true';
    } catch (e) {
      // localStorage unavailable (private browsing, etc.)
    }
    let rawPrompt = '';
    let editingLineIndex = null; // Currently editing line index

    // Filter state tracking
    let currentQuery = '';
    let currentTags = [];
    let availableTags = [];

    // Current prompt flags (for optimistic updates)
    let currentPromptFlags = { pinned: false, favorited: false };

    // Staging state (insert mode)
    let stagingPrompts = []; // Array of { tempId, data: { slug, name, description, content, tags } }
    let selectedStagingId = null;
    let savedListState = { query: '', tags: [], scrollTop: 0 }; // Preserved during insert mode
    let isDirty = false;

    // Draft state
    let currentDraft = null;
    let draftDebounceTimer = null;
    const DRAFT_DEBOUNCE_MS = 500;
    const EXPIRY_WARNING_MS = 2 * 60 * 60 * 1000; // 2 hours

    // Initialize modal component (from modal.js)
    initModal();

    // ============================================
    // HOST COMMUNICATION (via adapter)
    // ============================================

    /**
     * Notify host of portlet state change for history tracking.
     * @param {boolean} trackHistory - Whether to add to browser history (default: true)
     */
    function notifyShellStateChange(trackHistory = true) {
      platform.host.notifyStateChange({
        portlet: 'prompts',
        slug: selectedSlug,
        mode: currentMode,
        trackHistory
      });
    }

    /**
     * Signal to host that portlet is ready to receive state.
     */
    function notifyShellReady() {
      platform.host.notifyReady();
    }

    /**
     * Notify host of dirty state for confirmation prompts
     */
    function notifyShellDirtyState(dirty) {
      platform.host.notifyDirty(dirty);
    }

    /**
     * Notify host of draft changes.
     * @param {{count: number, latestDraftId: string|null, nextExpiryAt?: number, hasExpiringSoon: boolean}} summary
     */
    function notifyShellOfDrafts(summary) {
      platform.host.notifyDrafts(summary);
    }

    /**
     * Clear current selection and show empty state.
     * @param {Object} options
     * @param {boolean} options.trackHistory - Whether to add to browser history
     */
    function clearSelection({ trackHistory = true } = {}) {
      selectedSlug = null;
      currentMode = 'empty';

      document.querySelectorAll(".prompt-item").forEach((item) => {
        item.classList.remove("selected");
      });

      const emptyState = document.getElementById("empty-state");
      const promptView = document.getElementById("prompt-view");
      if (emptyState) emptyState.style.display = "flex";
      if (promptView) promptView.style.display = "none";

      if (trackHistory) {
        notifyShellStateChange(true);
      }
    }

    // ============================================
    // INSERT MODE (Staging)
    // ============================================

    /**
     * Generate a temporary ID for staging prompts
     */
    function generateTempId() {
      return 'temp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    /**
     * Enter insert mode - add a new prompt to staging
     */
    function enterInsertMode() {
      // Capture current form data before creating new entry
      if (selectedStagingId) {
        const current = stagingPrompts.find(s => s.tempId === selectedStagingId);
        if (current) {
          current.data = promptEditor.getFormData();
        }
      }

      // If first insert, save current list state
      if (stagingPrompts.length === 0) {
        const listEl = document.getElementById('prompt-list');
        savedListState = {
          query: currentQuery,
          tags: currentTags.slice(),
          scrollTop: listEl ? listEl.scrollTop : 0
        };
      }

      // Create new staging prompt
      const newPrompt = {
        tempId: generateTempId(),
        data: {
          slug: '',
          name: 'New Prompt',
          description: '',
          content: '',
          tags: []
        }
      };

      stagingPrompts.push(newPrompt);
      selectedStagingId = newPrompt.tempId;
      currentMode = 'new';

      renderStagingList();
      showEditor(newPrompt.data);
      isDirty = false; // Reset after showing new empty form
      updateStagingFooter();
      notifyShellStateChange(true);

      // Create draft entry for new prompt
      handleNewPrompt();
    }

    /**
     * Enter edit mode for an existing prompt
     */
    function enterEditMode() {
      if (!selectedSlug) return;

      const prompt = prompts.find(p => p.slug === selectedSlug);
      if (!prompt) return;

      currentMode = 'edit';
      showEditor(prompt);
      notifyShellStateChange(true);
    }

    /**
     * Show the editor with given data
     */
    function showEditor(data) {
      const emptyState = document.getElementById('empty-state');
      const promptView = document.getElementById('prompt-view');
      const promptEdit = document.getElementById('prompt-edit');

      if (emptyState) emptyState.style.display = 'none';
      if (promptView) promptView.style.display = 'none';
      if (promptEdit) promptEdit.style.display = 'block';

      promptEditor.init(promptEdit, {
        data,
        onSave: handleSave,
        onDiscard: handleDiscard,
        onDirtyChange: (dirty) => {
          isDirty = dirty;
          notifyShellDirtyState(dirty);
        },
        onChange: (field, value) => {
          handleEditModeChange(field, value);
        }
      });
    }

    /**
     * Hide the editor and show appropriate view
     */
    function hideEditor() {
      const promptEdit = document.getElementById('prompt-edit');
      if (promptEdit) promptEdit.style.display = 'none';

      promptEditor.destroy();
      isDirty = false;
      notifyShellDirtyState(false);
    }

    /**
     * Render the staging list in the sidebar
     */
    function renderStagingList() {
      const listEl = document.getElementById('prompt-list');
      if (!listEl) return;

      listEl.innerHTML = '';

      stagingPrompts.forEach((staging) => {
        const item = document.createElement('div');
        item.className = 'prompt-item staging';
        item.dataset.tempId = staging.tempId;

        if (staging.tempId === selectedStagingId) {
          item.classList.add('selected');
        }

        const name = staging.data.name || 'New Prompt';
        const slug = staging.data.slug || '(no slug)';

        item.innerHTML = `
          <div class="prompt-name">${escapeHtml(name)}</div>
          <div class="prompt-slug">${escapeHtml(slug)}</div>
          <div class="item-status">unsaved</div>
          <button class="btn-icon remove-staging" title="Remove">x</button>
        `;

        item.addEventListener('click', (e) => {
          if (e.target.classList.contains('remove-staging')) {
            removeStagingPrompt(staging.tempId);
          } else {
            selectStagingPrompt(staging.tempId);
          }
        });

        listEl.appendChild(item);
      });

      // Update staging header visibility
      updateStagingFooter();
    }

    /**
     * Select a staging prompt
     */
    async function selectStagingPrompt(tempId) {
      // Check dirty state first
      if (isDirty && selectedStagingId !== tempId) {
        if (!await showConfirm('Discard unsaved changes?')) return;
      }

      // Save current editor state back to staging
      if (selectedStagingId) {
        const current = stagingPrompts.find(s => s.tempId === selectedStagingId);
        if (current) {
          current.data = promptEditor.getFormData();
        }
      }

      selectedStagingId = tempId;
      const staging = stagingPrompts.find(s => s.tempId === tempId);
      if (staging) {
        showEditor(staging.data);
      }

      renderStagingList();
    }

    /**
     * Remove a prompt from staging
     */
    async function removeStagingPrompt(tempId) {
      if (isDirty && tempId === selectedStagingId) {
        if (!await showConfirm('Discard unsaved changes?')) return;
      }

      stagingPrompts = stagingPrompts.filter(s => s.tempId !== tempId);

      if (stagingPrompts.length === 0) {
        await exitInsertMode();
      } else if (selectedStagingId === tempId) {
        // Select the first remaining
        selectedStagingId = stagingPrompts[0].tempId;
        showEditor(stagingPrompts[0].data);
        renderStagingList();
      } else {
        renderStagingList();
      }

      updateStagingFooter();
    }

    /**
     * Update staging header visibility and count
     * Only shows when 2+ prompts are staged
     */
    function updateStagingFooter() {
      const header = document.getElementById('staging-header');
      const countEl = document.getElementById('staging-count');
      if (countEl) countEl.textContent = stagingPrompts.length;
      if (header) {
        header.style.display = stagingPrompts.length >= 2 ? 'flex' : 'none';
      }
    }

    /**
     * Exit insert mode and restore list
     */
    async function exitInsertMode() {
      stagingPrompts = [];
      selectedStagingId = null;
      hideEditor();

      const header = document.getElementById('staging-header');
      if (header) header.style.display = 'none';

      // Restore list (loadPrompts handles empty states internally)
      await loadPrompts(savedListState.query, savedListState.tags);

      // Restore scroll position
      const listEl = document.getElementById('prompt-list');
      if (listEl) listEl.scrollTop = savedListState.scrollTop;

      currentMode = 'empty';
      clearSelection({ trackHistory: true });
    }

    /**
     * Handle save from editor
     */
    async function handleSave(data) {
      try {
        if (currentMode === 'edit') {
          // Update existing prompt via adapter
          await platform.data.updatePrompt(selectedSlug, data);

          // Commit draft (delete draft after successful save)
          commitDraftToConvex();

          hideEditor();
          await loadPrompts();

          // If slug changed, select new slug
          selectPrompt(data.slug, { trackHistory: true });
        } else if (currentMode === 'new') {
          // Create new prompt via adapter
          await platform.data.createPrompts([data]);

          // Commit draft (delete draft after successful save)
          commitDraftToConvex();

          // Remove from staging
          stagingPrompts = stagingPrompts.filter(s => s.tempId !== selectedStagingId);

          if (stagingPrompts.length === 0) {
            await exitInsertMode();
            // Select the newly created prompt
            await loadPrompts();
            selectPrompt(data.slug, { trackHistory: true });
          } else {
            // More to save - select next
            selectedStagingId = stagingPrompts[0].tempId;
            showEditor(stagingPrompts[0].data);
            renderStagingList();
            updateStagingFooter();
          }
        }
      } catch (err) {
        console.error('Save failed:', err);
        handleSaveFailure(err);
        showToast(err.message || 'Failed to save prompt', { type: 'error' });
      }
    }

    /**
     * Handle discard from editor
     */
    function handleDiscard() {
      // Clear draft from storage
      clearDraftFromRedis();

      if (currentMode === 'edit') {
        hideEditor();
        currentMode = 'view';
        // Re-show the view
        const emptyState = document.getElementById('empty-state');
        const promptView = document.getElementById('prompt-view');
        if (emptyState) emptyState.style.display = 'none';
        if (promptView) promptView.style.display = 'block';
        notifyShellStateChange(true);
      } else if (currentMode === 'new') {
        removeStagingPrompt(selectedStagingId);
      }
    }

    /**
     * Save all staging prompts
     */
    async function saveAll() {
      if (stagingPrompts.length === 0) return;

      // Update current editor data
      if (selectedStagingId) {
        const current = stagingPrompts.find(s => s.tempId === selectedStagingId);
        if (current) {
          current.data = promptEditor.getFormData();
        }
      }

      // Validate current prompt with inline errors
      const errors = promptEditor.validate();
      if (Object.keys(errors).length > 0) {
        // Trigger the save button to show inline errors
        const saveBtn = document.getElementById('btn-save');
        if (saveBtn) saveBtn.click();
        return;
      }

      // Validate all staged prompts
      const promptsToSave = stagingPrompts.map(s => s.data);
      for (let i = 0; i < promptsToSave.length; i++) {
        const data = promptsToSave[i];
        if (!data.slug || !data.name || !data.description || !data.content) {
          // Find the staging prompt with issues and switch to it
          const staging = stagingPrompts[i];
          if (staging.tempId !== selectedStagingId) {
            await selectStagingPrompt(staging.tempId);
            showToast('This prompt has missing required fields', { type: 'error' });
          }
          return;
        }
      }

      try {
        await platform.data.createPrompts(promptsToSave);

        await exitInsertMode();
        // Select first created prompt
        await loadPrompts();
        if (promptsToSave.length > 0) {
          selectPrompt(promptsToSave[0].slug, { trackHistory: true });
        }
      } catch (err) {
        console.error('Save all failed:', err);
        showToast(err.message || 'Failed to save prompts', { type: 'error' });
      }
    }

    /**
     * Discard all staging prompts
     */
    async function discardAll() {
      if (stagingPrompts.length === 0) return;

      if (!await showConfirm(`Discard all ${stagingPrompts.length} unsaved prompt(s)?`)) return;

      await exitInsertMode();
    }

    // Initialize view mode from localStorage
    function initViewMode() {
      const viewer = document.getElementById('promptViewer');
      viewer.className = `prompt-viewer view-${currentView}`;
      viewer.querySelectorAll('[data-view]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.view === currentView);
      });
    }

    // Display prompt content with current view mode
    function displayPromptContent(content) {
      rawPrompt = content;
      const contentEl = document.getElementById('promptContent');

      // Only enable line edit in semantic/plain views, not rendered
      const effectiveLineEdit = lineEditEnabled && currentView !== 'rendered';
      const { html, stats } = renderPrompt(content, currentView, { lineEdit: effectiveLineEdit });
      contentEl.innerHTML = html || '<span style="color: var(--text-muted)">No content</span>';

      document.getElementById('statTags').textContent = stats.tags;
      document.getElementById('statVars').textContent = stats.vars;
      document.getElementById('statChars').textContent = content.length;

      // Set up line edit click handlers if enabled and not in rendered view
      if (effectiveLineEdit) {
        setupLineEditHandlers();
      }
    }

    // ============================================
    // LINE EDIT MODE
    // ============================================

    /**
     * Initialize line edit toggle state
     */
    function initLineEditMode() {
      const toggle = document.getElementById('line-edit-toggle');
      if (!toggle) return;

      toggle.classList.toggle('active', lineEditEnabled);
      const viewer = document.getElementById('promptViewer');
      if (viewer) {
        viewer.classList.toggle('line-edit-mode', lineEditEnabled);
      }
    }

    /**
     * Toggle line edit mode (disabled in rendered view)
     */
    function toggleLineEdit() {
      // Line edit not available in rendered view
      if (currentView === 'rendered') return;

      lineEditEnabled = !lineEditEnabled;

      try {
        localStorage.setItem('lineEditEnabled', lineEditEnabled.toString());
      } catch (e) {
        // localStorage unavailable
      }

      const toggle = document.getElementById('line-edit-toggle');
      if (toggle) toggle.classList.toggle('active', lineEditEnabled);

      const viewer = document.getElementById('promptViewer');
      if (viewer) viewer.classList.toggle('line-edit-mode', lineEditEnabled);

      // Re-render content with new mode
      if (rawPrompt) {
        displayPromptContent(rawPrompt);
      }
    }

    /**
     * Update line edit toggle availability based on view mode
     */
    function updateLineEditAvailability() {
      const toggle = document.getElementById('line-edit-toggle');
      if (!toggle) return;

      if (currentView === 'rendered') {
        // Disable line edit in rendered view
        toggle.disabled = true;
        toggle.classList.remove('active');
        toggle.title = 'Line edit not available in Rendered view';

        const viewer = document.getElementById('promptViewer');
        if (viewer) viewer.classList.remove('line-edit-mode');
      } else {
        // Enable line edit in plain/semantic views
        toggle.disabled = false;
        toggle.title = 'Enable line-by-line editing';

        // Restore saved state
        if (lineEditEnabled) {
          toggle.classList.add('active');
          const viewer = document.getElementById('promptViewer');
          if (viewer) viewer.classList.add('line-edit-mode');
        }
      }
    }

    /**
     * Set up click handlers for editable lines
     */
    function setupLineEditHandlers() {
      const contentEl = document.getElementById('promptContent');
      if (!contentEl) return;

      contentEl.querySelectorAll('.editable-line').forEach(lineEl => {
        lineEl.addEventListener('click', (e) => {
          // Don't trigger if clicking on an existing input
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

          const lineIndex = parseInt(lineEl.dataset.line, 10);
          startLineEdit(lineIndex, lineEl);
        });
      });
    }

    /**
     * Start editing a specific line
     */
    function startLineEdit(lineIndex, lineEl) {
      // If already editing another line, save it first
      if (editingLineIndex !== null && editingLineIndex !== lineIndex) {
        saveCurrentLineEdit();
      }

      editingLineIndex = lineIndex;
      const lines = rawPrompt.split('\n');
      const lineContent = lines[lineIndex] || '';

      // Create inline input
      const input = document.createElement('textarea');
      input.className = 'line-edit-input';
      input.value = lineContent;
      input.rows = 1;

      // Auto-resize based on content
      input.style.width = '100%';
      input.style.minWidth = Math.max(lineEl.offsetWidth, 300) + 'px';

      // Replace line content with input
      lineEl.innerHTML = '';
      lineEl.appendChild(input);
      lineEl.classList.add('editing');

      // Focus and select all
      input.focus();
      input.select();

      // Auto-resize height
      const autoResize = () => {
        input.style.height = 'auto';
        input.style.height = input.scrollHeight + 'px';
      };
      input.addEventListener('input', autoResize);
      autoResize();

      // Save on blur
      input.addEventListener('blur', () => {
        saveLineEdit(lineIndex, input.value);
      });

      // Save on Enter (Shift+Enter for newline would need multiline support)
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          input.blur(); // Triggers save via blur handler
        }
        if (e.key === 'Escape') {
          e.preventDefault();
          editingLineIndex = null;
          displayPromptContent(rawPrompt); // Re-render without saving
        }
      });
    }

    /**
     * Save the currently editing line
     */
    function saveCurrentLineEdit() {
      const contentEl = document.getElementById('promptContent');
      if (!contentEl || editingLineIndex === null) return;

      const editingEl = contentEl.querySelector('.editable-line.editing');
      if (!editingEl) return;

      const input = editingEl.querySelector('.line-edit-input');
      if (input) {
        saveLineEdit(editingLineIndex, input.value);
      }
    }

    /**
     * Save a line edit and update the prompt
     */
    async function saveLineEdit(lineIndex, newValue) {
      const lines = rawPrompt.split('\n');
      const oldValue = lines[lineIndex] || '';
      const contentEl = document.getElementById('promptContent');
      const lineEl = contentEl?.querySelector(`.editable-line[data-line="${lineIndex}"]`);

      // No change, just re-render
      if (newValue === oldValue) {
        editingLineIndex = null;
        if (lineEl) {
          lineEl.classList.remove('editing');
          lineEl.textContent = oldValue;
        } else {
          displayPromptContent(rawPrompt);
        }
        return;
      }

      // Update local content
      lines[lineIndex] = newValue;
      const newContent = lines.join('\n');

      // Get current prompt data
      const prompt = prompts.find(p => p.slug === selectedSlug);
      if (!prompt) {
        editingLineIndex = null;
        if (lineEl) {
          lineEl.classList.remove('editing');
          lineEl.textContent = oldValue;
        } else {
          displayPromptContent(rawPrompt);
        }
        return;
      }

      // Save to draft (line edit -> draft, not immediate save)
      handleLineEdit('content', newContent);

      // Do NOT write through to API here. Line edits are draft-only until explicit Save.
      prompt.content = newContent;
      rawPrompt = newContent;
      editingLineIndex = null;

      if (lineEl) {
        lineEl.classList.remove('editing');
        lineEl.textContent = newValue;
      } else {
        displayPromptContent(newContent);
      }
    }

    // ============================================
    // LOAD PROMPTS (via adapter)
    // ============================================

    async function loadPrompts(query = '', tags = []) {
      currentQuery = query;
      currentTags = tags;

      try {
        const data = await platform.data.listPrompts(query, tags);
        prompts = Array.isArray(data) ? data : [];

        if (prompts.length === 0) {
          if (currentQuery || currentTags.length > 0) {
            renderEmptyState('no-matches');
          } else {
            renderEmptyState('no-prompts');
          }
        } else {
          renderPromptList(prompts);
        }

        if (selectedSlug) {
          const stillExists = prompts.some((prompt) => prompt.slug === selectedSlug);
          if (stillExists) {
            selectPrompt(selectedSlug, { trackHistory: false });
          }
        }
      } catch (err) {
        console.error('Filter failed:', err);
        showToast('Failed to filter prompts', { type: 'error' });
      }
    }


    // Render prompt list with proper pin/star indicators
    function renderPromptList(prompts) {
      const list = document.getElementById('prompt-list');
      const emptyState = document.getElementById('empty-state');

      if (!list) return;

      list.innerHTML = '';
      if (emptyState) emptyState.style.display = 'none';

      prompts.forEach((prompt) => {
        const item = renderPromptListItem(prompt);
        list.appendChild(item);
      });
    }

    function renderPromptListItem(prompt) {
      const item = document.createElement('div');
      item.className = 'prompt-item';
      item.dataset.slug = prompt.slug;

      if (prompt.slug === selectedSlug) {
        item.classList.add('selected');
      }

      const tagsHtml = (prompt.tags || [])
        .map((tag) => `<span class="tag">${escapeHtml(tag)}</span>`)
        .join(" ");

      // Use .prompt-pin and .prompt-star classes (test hooks)
      const pinIndicator = prompt.pinned
        ? '<span class="prompt-pin" title="Pinned">pinned</span>'
        : '<span class="prompt-pin" style="display:none">pinned</span>';

      const favoriteIndicator = prompt.favorited
        ? '<span class="prompt-star" title="Favorited">starred</span>'
        : '<span class="prompt-star" style="display:none">starred</span>';

      item.innerHTML = `
        <div class="prompt-name">${escapeHtml(prompt.name)}</div>
        <div class="prompt-slug">${escapeHtml(prompt.slug)}</div>
        <div class="prompt-tags">${tagsHtml}</div>
        <div class="prompt-indicators">
          ${pinIndicator}
          ${favoriteIndicator}
        </div>
      `;

      item.addEventListener('click', () => selectPrompt(prompt.slug));
      return item;
    }

    // Select prompt
    function selectPrompt(slug, { trackHistory = true } = {}) {
      const prompt = prompts.find((item) => item.slug === slug);
      if (!prompt) {
        return;
      }

      selectedSlug = slug;
      currentMode = 'view';

      document.querySelectorAll(".prompt-item").forEach((item) => {
        if (item.dataset.slug === slug) {
          item.classList.add("selected");
        } else {
          item.classList.remove("selected");
        }
      });

      const emptyState = document.getElementById("empty-state");
      const promptView = document.getElementById("prompt-view");
      if (emptyState) emptyState.style.display = "none";
      if (promptView) promptView.style.display = "block";

      const slugEl = document.getElementById("prompt-slug");
      const descEl = document.getElementById("prompt-description");
      if (slugEl) slugEl.textContent = prompt.slug;
      if (descEl) descEl.textContent = prompt.description;

      // Update current prompt flags
      currentPromptFlags = {
        pinned: prompt.pinned ?? false,
        favorited: prompt.favorited ?? false,
      };

      // Update pin/favorite toggle states
      updatePinUI(slug, currentPromptFlags.pinned);
      updateFavoriteUI(slug, currentPromptFlags.favorited);

      // Use prompt viewer to display content
      displayPromptContent(prompt.content || '');

      // Notify host for history tracking
      if (trackHistory) {
        notifyShellStateChange(true);
      }
    }

    // Copy to clipboard
    async function copyContent() {
      if (!rawPrompt) return;

      try {
        await navigator.clipboard.writeText(rawPrompt);
        const copyBtn = document.getElementById("copy-btn");
        if (!copyBtn) return;
        const originalText = copyBtn.textContent;
        copyBtn.textContent = "Copied!";
        setTimeout(() => {
          copyBtn.textContent = originalText;
        }, 1200);

        // Track usage after successful copy via adapter
        if (selectedSlug) {
          platform.data.trackUsage(selectedSlug).catch(() => {}); // fire-and-forget
        }
      } catch (err) {
        console.error('Failed to copy:', err);
      }
    }

    // View toggle buttons
    document.getElementById('promptViewer').querySelectorAll('[data-view]').forEach(btn => {
      btn.addEventListener('click', () => {
        const viewer = document.getElementById('promptViewer');
        viewer.querySelectorAll('[data-view]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentView = btn.dataset.view;
        try {
          localStorage.setItem('promptViewMode', currentView);
        } catch (e) {
          // localStorage unavailable (private browsing, etc.)
        }
        viewer.className = `prompt-viewer view-${currentView}`;
        updateLineEditAvailability();
        if (rawPrompt) displayPromptContent(rawPrompt);
      });
    });

    // ============================================
    // DRAFT MANAGEMENT (via adapter)
    // ============================================

    /**
     * Get the draft ID for the current editing context.
     */
    function getDraftIdForCurrentContext() {
      if (currentDraft?.draftId) return currentDraft.draftId;
      if (currentMode === 'edit' && selectedSlug) return `edit:${selectedSlug}`;
      if (currentMode === 'new') return `new:${selectedStagingId || generateTempId()}`;
      // Line edits in view mode should also be saved under edit:${slug}
      if (currentMode === 'view' && selectedSlug) return `edit:${selectedSlug}`;
      return null;
    }

    /**
     * Get the draft type for the current editing context.
     */
    function getDraftTypeForCurrentContext() {
      if (currentDraft?.type) return currentDraft.type;
      if (currentMode === 'new') return 'new';
      return 'edit';
    }

    async function fetchDraftSummaryForHost() {
      try {
        return await platform.data.getDraftSummary();
      } catch {
        return null;
      }
    }

    /**
     * Auto-save to draft on edit mode changes
     */
    function handleEditModeChange(field, value) {
      clearTimeout(draftDebounceTimer);
      draftDebounceTimer = setTimeout(() => {
        saveToDraft();
      }, DRAFT_DEBOUNCE_MS);
    }

    /**
     * Save current editor state to draft storage via adapter.
     */
    async function saveToDraft(override = null) {
      const draftId = override?.draftId || getDraftIdForCurrentContext();
      if (!draftId) return;

      const type = override?.type || getDraftTypeForCurrentContext();
      const promptSlug = override?.promptSlug ?? selectedSlug;
      let data = override?.data || null;
      if (!data) {
        try {
          if (typeof promptEditor !== 'undefined' && promptEditor.getFormData) {
            data = promptEditor.getFormData();
          }
        } catch {
          return;
        }
      }
      if (!data) return;

      const payload = {
        type,
        promptSlug,
        data,
      };

      try {
        const saved = await platform.data.saveDraft(draftId, payload);
        currentDraft = { ...payload, ...saved, draftId };
        const summary = await fetchDraftSummaryForHost();
        if (summary) notifyShellOfDrafts(summary);
      } catch (err) {
        console.error('Draft save failed:', err);
        currentDraft = { ...payload, draftId };
      }
    }

    /**
     * Line edit -> draft (not immediate save)
     */
    function handleLineEdit(field, value) {
      if (!selectedSlug) return;
      const prompt = prompts.find(p => p.slug === selectedSlug);
      if (!prompt) return;

      const updated = {
        slug: prompt.slug,
        name: prompt.name,
        description: prompt.description,
        content: prompt.content,
        tags: prompt.tags || [],
      };
      updated[field] = value;

      const draftId = `edit:${selectedSlug}`;
      currentDraft = { draftId, type: 'edit', promptSlug: selectedSlug, data: updated };

      clearTimeout(draftDebounceTimer);
      saveToDraft({ draftId, type: 'edit', promptSlug: selectedSlug, data: updated });
    }

    /**
     * +New creates draft entry
     */
    function handleNewPrompt() {
      const draftId = `new:${selectedStagingId || generateTempId()}`;
      let data = null;
      try {
        data = promptEditor.getFormData();
      } catch {
        return;
      }
      currentDraft = { draftId, type: 'new', promptSlug: null, data };
      saveToDraft({ draftId, type: 'new', promptSlug: null, data });
    }

    /**
     * Save button commits draft (deletes draft after successful save)
     */
    function commitDraftToConvex() {
      const draftId = getDraftIdForCurrentContext();
      if (!draftId) return;
      platform.data.deleteDraft(draftId)
        .then(async () => {
          currentDraft = null;
          const summary = await fetchDraftSummaryForHost();
          if (summary) notifyShellOfDrafts(summary);
        })
        .catch(() => {});
    }

    /**
     * Discard button clears draft
     */
    function clearDraftFromRedis() {
      const draftId = getDraftIdForCurrentContext();
      if (!draftId) return;
      platform.data.deleteDraft(draftId)
        .then(async () => {
          currentDraft = null;
          const summary = await fetchDraftSummaryForHost();
          if (summary) notifyShellOfDrafts(summary);
        })
        .catch((err) => console.warn('Draft cleanup failed:', err));
    }

    /**
     * Save failure preserves draft
     */
    function handleSaveFailure(error) {
      console.error('Save failed:', error);
    }

    /**
     * Check draft expiration and show warning if expiring soon.
     */
    function checkDraftExpiration(draft) {
      const warningEl = document.querySelector('.draft-expiry-warning');
      if (!warningEl) return;
      if (!draft || typeof draft.expiresAt !== 'number') {
        warningEl.style.display = 'none';
        return;
      }
      const remaining = draft.expiresAt - Date.now();
      warningEl.style.display = remaining < EXPIRY_WARNING_MS ? 'block' : 'none';
    }

    /**
     * Open draft from host request.
     */
    async function openDraft(draftId) {
      if (!draftId) return;
      try {
        const drafts = await platform.data.listDrafts();
        const draft = drafts.find(d => d.draftId === draftId);
        if (!draft) return;
        currentDraft = draft;

        // Always select the prompt first so the slug header updates
        if (draft.promptSlug) {
          selectPrompt(draft.promptSlug, { trackHistory: false });
        }

        if (draft.type === 'new') {
          const tempId = draft.draftId.replace(/^new:/, '');

          if (stagingPrompts.length === 0) {
            const listEl = document.getElementById('prompt-list');
            savedListState = {
              query: currentQuery,
              tags: currentTags.slice(),
              scrollTop: listEl ? listEl.scrollTop : 0
            };
          }

          stagingPrompts.push({
            tempId: tempId,
            data: draft.data
          });
          selectedStagingId = tempId;
          currentMode = 'new';

          renderStagingList();
          showEditor(draft.data);
          isDirty = false;
          updateStagingFooter();
        } else {
          selectedSlug = draft.promptSlug || selectedSlug;
          currentMode = 'edit';
          showEditor(draft.data);
        }

        checkDraftExpiration(draft);
      } catch (err) {
        console.error('Failed to open draft:', err);
      }
    }

    // ============================================
    // THEME MANAGEMENT
    // ============================================

    /**
     * Apply theme to widget by updating CSS link.
     */
    function applyTheme(themeId) {
      if (!VALID_THEMES.includes(themeId)) {
        console.error('Invalid theme:', themeId);
        return;
      }

      const themeStylesheet = document.getElementById('theme-stylesheet');
      if (themeStylesheet) {
        themeStylesheet.href = `/shared/themes/${themeId}.css`;
      }
    }

    // ============================================
    // SEARCH/FILTER UI
    // ============================================

    let searchDebounceTimer;

    /**
     * Initialize search input with debounce
     */
    function initSearchInput() {
      const searchInput = document.getElementById('search-input');
      if (!searchInput) return;

      searchInput.addEventListener('input', (e) => {
        clearTimeout(searchDebounceTimer);
        searchDebounceTimer = setTimeout(() => {
          loadPrompts(e.target.value, currentTags);
        }, 150);
      });
    }

    /**
     * Initialize tag picker dropdown
     */
    async function initTagPicker() {
      try {
        availableTags = await platform.data.listTags();
      } catch (err) {
        console.error('Failed to load tags:', err);
        availableTags = [];
      }

      renderTagPicker();
      setupTagPickerHandlers();
    }

    /**
     * Render tag picker dropdown items
     */
    function renderTagPicker() {
      const dropdown = document.getElementById('tag-picker-dropdown');
      const countEl = document.getElementById('tag-count');
      if (!dropdown) return;

      if (availableTags.length === 0) {
        dropdown.innerHTML = '<div class="tag-picker-empty">No tags available</div>';
        return;
      }

      dropdown.innerHTML = availableTags.map(tag => {
        const isSelected = currentTags.includes(tag);
        return `
          <div class="tag-picker-item${isSelected ? ' selected' : ''}" data-tag="${escapeHtml(tag)}">
            <span class="check">&#10003;</span>
            <span class="tag-name">${escapeHtml(tag)}</span>
          </div>
        `;
      }).join('');

      // Update count badge
      if (countEl) {
        countEl.textContent = currentTags.length > 0 ? `(${currentTags.length})` : '';
      }
    }

    /**
     * Set up tag picker event handlers
     */
    function setupTagPickerHandlers() {
      const btn = document.getElementById('tag-picker-btn');
      const dropdown = document.getElementById('tag-picker-dropdown');
      if (!btn || !dropdown) return;

      // Toggle dropdown
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        dropdown.classList.toggle('open');
        dropdown.classList.toggle('hidden', !dropdown.classList.contains('open'));
      });

      // Handle tag selection
      dropdown.addEventListener('click', (e) => {
        const item = e.target.closest('.tag-picker-item');
        if (!item) return;

        const tag = item.dataset.tag;
        if (currentTags.includes(tag)) {
          currentTags = currentTags.filter(t => t !== tag);
        } else {
          currentTags.push(tag);
        }

        renderTagPicker();
        renderFilterTags();
        loadPrompts(currentQuery, currentTags);
      });

      // Close dropdown on outside click
      document.addEventListener('click', (e) => {
        if (!btn.contains(e.target) && !dropdown.contains(e.target)) {
          dropdown.classList.remove('open');
          dropdown.classList.add('hidden');
        }
      });
    }

    /**
     * Render active filter tags below search
     */
    function renderFilterTags() {
      const container = document.getElementById('filter-tags');
      if (!container) return;

      if (currentTags.length === 0) {
        container.innerHTML = '';
        return;
      }

      container.innerHTML = currentTags.map(tag => `
        <span class="filter-pill" data-tag="${escapeHtml(tag)}">
          ${escapeHtml(tag)}
          <button class="remove" title="Remove filter">&times;</button>
        </span>
      `).join('');

      // Handle remove clicks
      container.querySelectorAll('.remove').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const pill = btn.closest('.filter-pill');
          const tag = pill?.dataset.tag;
          if (tag) {
            currentTags = currentTags.filter(t => t !== tag);
            renderTagPicker();
            renderFilterTags();
            loadPrompts(currentQuery, currentTags);
          }
        });
      });
    }

    // ============================================
    // PIN/FAVORITE HANDLERS (via adapter)
    // ============================================

    async function handlePinToggle(slug, currentPinned) {
      const originalFlags = { ...currentPromptFlags };
      const newPinned = !currentPinned;

      // Optimistic UI update
      updatePinUI(slug, newPinned);
      currentPromptFlags.pinned = newPinned;

      try {
        await platform.data.updateFlags(slug, { pinned: newPinned });
        await loadPrompts(currentQuery, currentTags);
      } catch (err) {
        console.error('Pin toggle failed:', err);
        handleOptimisticRollback(slug, originalFlags);
        showToast('Failed to update pin status', { type: 'error' });
      }
    }

    async function handleFavoriteToggle(slug, currentFavorited) {
      const originalFlags = { ...currentPromptFlags };
      const newFavorited = !currentFavorited;

      // Optimistic UI update
      updateFavoriteUI(slug, newFavorited);
      currentPromptFlags.favorited = newFavorited;

      try {
        await platform.data.updateFlags(slug, { favorited: newFavorited });
        await loadPrompts(currentQuery, currentTags);
      } catch (err) {
        console.error('Favorite toggle failed:', err);
        handleOptimisticRollback(slug, originalFlags);
        showToast('Failed to update favorite status', { type: 'error' });
      }
    }

    function handleOptimisticRollback(slug, previousFlags) {
      updatePinUI(slug, previousFlags.pinned);
      updateFavoriteUI(slug, previousFlags.favorited);
      currentPromptFlags = previousFlags;
    }

    function updatePinUI(slug, pinned) {
      const pinButton = document.getElementById('pin-toggle');
      if (pinButton) {
        pinButton.classList.toggle('active', pinned);
        pinButton.setAttribute('aria-pressed', String(pinned));
        pinButton.title = pinned ? 'Unpin prompt' : 'Pin prompt';
      }

      const listItem = document.querySelector(`[data-slug="${slug}"] .prompt-pin`);
      if (listItem) {
        listItem.style.display = pinned ? '' : 'none';
      }
    }

    function updateFavoriteUI(slug, favorited) {
      const starButton = document.getElementById('favorite-toggle');
      if (starButton) {
        starButton.classList.toggle('active', favorited);
        starButton.setAttribute('aria-pressed', String(favorited));
        starButton.title = favorited ? 'Unfavorite prompt' : 'Favorite prompt';
      }

      const listItem = document.querySelector(`[data-slug="${slug}"] .prompt-star`);
      if (listItem) {
        listItem.style.display = favorited ? '' : 'none';
      }
    }

    // Empty state rendering
    function renderEmptyState(type) {
      const list = document.getElementById('prompt-list');
      const emptyState = document.getElementById('empty-state');

      if (!list || !emptyState) return;

      list.innerHTML = '';
      emptyState.style.display = 'flex';

      if (type === 'no-prompts') {
        emptyState.innerHTML = `
          <div class="empty-state-content">
            <p>Create your first prompt to get started.</p>
            <button id="empty-state-new-btn" class="btn-primary">+ New Prompt</button>
          </div>
        `;
        const newBtn = emptyState.querySelector('#empty-state-new-btn');
        if (newBtn) {
          newBtn.onclick = () => enterInsertMode();
        }
      } else if (type === 'no-matches') {
        emptyState.innerHTML = `
          <div class="empty-state-content">
            <p>No prompts match your search.</p>
          </div>
        `;
      }
    }

    // ============================================
    // EVENT LISTENERS
    // ============================================

    // New prompt - enter insert mode
    document.getElementById('new-prompt-btn').addEventListener('click', () => {
      enterInsertMode();
    });

    // Edit button
    document.getElementById('edit-btn').addEventListener('click', () => {
      enterEditMode();
    });

    // Line edit toggle
    document.getElementById('line-edit-toggle').addEventListener('click', toggleLineEdit);

    // Staging footer buttons
    document.getElementById('save-all-btn').addEventListener('click', saveAll);
    document.getElementById('discard-all-btn').addEventListener('click', discardAll);

    // Copy button
    document.getElementById('copy-btn').addEventListener('click', copyContent);

    // Pin toggle button
    document.getElementById('pin-toggle').addEventListener('click', () => {
      if (!selectedSlug) return;
      handlePinToggle(selectedSlug, currentPromptFlags.pinned);
    });

    // Favorite toggle button
    document.getElementById('favorite-toggle').addEventListener('click', () => {
      if (!selectedSlug) return;
      handleFavoriteToggle(selectedSlug, currentPromptFlags.favorited);
    });

    // ============================================
    // INITIALIZATION
    // ============================================

    // Initialize view mode and line edit
    initViewMode();
    initLineEditMode();
    updateLineEditAvailability();

    // Expose functions for external use
    window.loadPrompts = loadPrompts;
    window.selectPrompt = selectPrompt;
    window.clearSelection = clearSelection;

    async function init() {
      // [WIDGET CHANGE] Auth validation moved to tryInit() wrapper
      // This function is only called after userId is confirmed available
      const initialData = platform.widget.getInitialData();

      // Initialize search/filter UI
      initSearchInput();
      await initTagPicker();

      // Use initial data from tool output if available
      if (initialData?.prompts) {
        prompts = initialData.prompts;
        renderPromptList(prompts);
      } else {
        await loadPrompts();
      }

      // Apply theme from environment
      const theme = platform.env.getTheme();
      applyTheme(theme);

      // Listen for theme changes
      platform.env.onThemeChange(applyTheme);

      // Request fullscreen mode
      await platform.widget.requestFullscreen();

      // If we already have a slug (from initial data), select it
      if (selectedSlug && prompts.length > 0) {
        const prompt = prompts.find(p => p.slug === selectedSlug);
        if (prompt) {
          selectPrompt(selectedSlug, { trackHistory: false });
        }
      }

      // Tell host we're ready
      notifyShellReady();
    }

    // [WIDGET CHANGE] Handle async data arrival - toolOutput might not be ready immediately
    let initialized = false;

    async function tryInit() {
      if (initialized) return;

      const initialData = platform?.widget?.getInitialData();
      if (initialData?.userId) {
        initialized = true;
        await init();
      }
    }

    if (!navigator.userAgent.includes("jsdom")) {
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", tryInit);
      } else {
        tryInit();
      }

      // [WIDGET CHANGE] Listen for async data arrival (CRITICAL for Skybridge)
      window.addEventListener('openai:set_globals', tryInit);
    }
  </script>
</body>
</html>
