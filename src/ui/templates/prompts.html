<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Prompts</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=IBM+Plex+Sans:wght@400;500;600&family=Playfair+Display:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/shared/themes/base.css">
  <link rel="stylesheet" href="/shared/themes/dark-1.css" id="theme-stylesheet">
  <link rel="stylesheet" href="/shared/prompt-viewer.css">
  <link rel="stylesheet" href="/shared/home-landing.css">
  <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.1.0/dist/markdown-it.min.js" integrity="sha384-wLhprpjsmjc/XYIcF+LpMxd8yS1gss6jhevOp6F6zhiIoFK6AmHtm4bGKtehTani" crossorigin="anonymous"></script>
</head>
<body class="module prompts-module">
  <aside class="sidebar">
    <div class="sidebar-header">
      <button id="new-prompt-btn" class="btn-primary">+ New</button>
    </div>
    <!-- Primary sidebar: Prompt list (shown on Home tab or when viewing prompts) -->
    <div id="prompt-list" class="prompt-list">
      <!-- Populated by JavaScript -->
    </div>
    <!-- Secondary sidebar: Integration nav (hidden by default) -->
    <div id="integration-nav" class="integration-nav" style="display: none;">
      <!-- Populated dynamically based on active tab -->
    </div>
  </aside>

  <main class="content">
    <!-- Home Module with Tab Navigation -->
    <div id="home-module" class="home-module">
      <nav class="home-tabs">
        <button class="home-tab active" data-tab="home">Home</button>
        <button class="home-tab" data-tab="getting-started">Getting Started</button>
        <button class="home-tab" data-tab="ai-assistants">AI Assistants</button>
        <button class="home-tab" data-tab="code-editors">Code Editors</button>
        <button class="home-tab" data-tab="developer">Developer</button>
        <button class="home-tab" data-tab="help">Help</button>
      </nav>

      <div class="home-content">
        <!-- Tab: Home (Editorial Landing) -->
        <section id="tab-home" class="tab-panel active">
          <div class="landing-editorial">
            <header class="landing-header">
              <span class="issue-label">Your Prompt Library</span>
              <h1 class="landing-headline">The prompts that <em>define</em><br>how you work with AI</h1>
              <p class="landing-tagline">Capture once, retrieve anywhere. Your knowledge, always within reach.</p>
            </header>

            <div class="feature-grid">
              <article class="feature-card">
                <span class="feature-icon">
                  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="2" y1="12" x2="22" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></svg>
                </span>
                <h3>Access Anywhere</h3>
                <p>Claude, Cursor, VS Code, ChatGPT. One library across every AI surface.</p>
              </article>
              <article class="feature-card">
                <span class="feature-icon">
                  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg>
                </span>
                <h3>19 Shared Tags</h3>
                <p>Organize by purpose, domain, or task. Find the right prompt instantly.</p>
              </article>
              <article class="feature-card">
                <span class="feature-icon">
                  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="20" x2="18" y2="10"/><line x1="12" y1="20" x2="12" y2="4"/><line x1="6" y1="20" x2="6" y2="14"/></svg>
                </span>
                <h3>Smart Ranking</h3>
                <p>Usage, recency, favorites. Your best prompts surface first.</p>
              </article>
            </div>

            <div class="landing-cta">
              <button id="cta-new-prompt" class="btn-primary btn-lg">+ Create Your First Prompt</button>
              <span class="cta-hint">or press <kbd>Cmd</kbd>+<kbd>K</kbd> to search</span>
            </div>

            <footer class="landing-access">
              <span class="access-label">Access via:</span>
              <span class="access-methods">
                <span class="access-method">Web UI</span>
                <span class="access-separator">‚Ä¢</span>
                <span class="access-method">MCP</span>
                <span class="access-separator">‚Ä¢</span>
                <span class="access-method">REST API</span>
              </span>
            </footer>
          </div>
        </section>

        <!-- Tab: Getting Started -->
        <section id="tab-getting-started" class="tab-panel">
          <div class="docs-content">
            <h1>Getting Started with LiminalDB</h1>

            <section class="docs-section">
              <h2>Your First Prompt</h2>
              <ol class="docs-steps">
                <li>Click <strong>+ New</strong> in the sidebar</li>
                <li>Fill in the details:
                  <ul>
                    <li><strong>Slug</strong>: A short identifier (e.g., <code>code-review</code>)</li>
                    <li><strong>Name</strong>: Display name (e.g., "Code Review Assistant")</li>
                    <li><strong>Description</strong>: Brief summary</li>
                    <li><strong>Content</strong>: Your prompt text</li>
                    <li><strong>Tags</strong>: Select from 19 shared tags</li>
                  </ul>
                </li>
                <li>Click <strong>Save</strong></li>
              </ol>
            </section>

            <section class="docs-section">
              <h2>Organizing Your Library</h2>
              <ul class="docs-list">
                <li><strong>Pin</strong> frequently used prompts (üìå)</li>
                <li><strong>Favorite</strong> your best prompts (‚≠ê)</li>
                <li>Use <strong>tags</strong> to categorize by purpose, domain, or task</li>
              </ul>
            </section>

            <section class="docs-section">
              <h2>Searching & Filtering</h2>
              <ul class="docs-list">
                <li>Press <kbd>Cmd</kbd>+<kbd>K</kbd> to search by content</li>
                <li>Use tag filters to narrow results</li>
                <li>Prompts ranked by usage, recency, and favorites</li>
              </ul>
            </section>

            <section class="docs-section">
              <h2>Tips</h2>
              <ul class="docs-list">
                <li>Drafts auto-save every few seconds</li>
                <li>Line edits accumulate until you save</li>
                <li>Use semantic view to see structure</li>
              </ul>
            </section>
          </div>
        </section>

        <!-- Tab: AI Assistants -->
        <section id="tab-ai-assistants" class="tab-panel">
          <div class="integration-content">
            <!-- Claude.ai -->
            <div data-content="claude-ai" class="integration-guide">
              <h1>Claude.ai Integration</h1>
              <p class="integration-intro">Access your prompts directly from Claude desktop via the Model Context Protocol (MCP).</p>

              <section class="setup-section">
                <h2>Quick Setup</h2>

                <div class="setup-step">
                  <span class="step-number">1</span>
                  <div class="step-content">
                    <p>Install the MCP server:</p>
                    <div class="code-block">
                      <code>npm install -g @liminaldb/mcp</code>
                      <button class="copy-code-btn" title="Copy">Copy</button>
                    </div>
                  </div>
                </div>

                <div class="setup-step">
                  <span class="step-number">2</span>
                  <div class="step-content">
                    <p>Add to Claude desktop config (<code>~/Library/Application Support/Claude/claude_desktop_config.json</code>):</p>
                    <div class="code-block">
<pre><code>{
  "mcpServers": {
    "liminaldb": {
      "command": "liminaldb-mcp",
      "env": { "LIMINALDB_API_KEY": "your-api-key" }
    }
  }
}</code></pre>
                      <button class="copy-code-btn" title="Copy">Copy</button>
                    </div>
                  </div>
                </div>

                <div class="setup-step">
                  <span class="step-number">3</span>
                  <div class="step-content">
                    <p>Restart Claude desktop</p>
                  </div>
                </div>
              </section>

              <div class="video-placeholder">
                <div class="video-icon">‚ñ∂</div>
                <span>Watch the setup walkthrough</span>
              </div>

              <section class="usage-section">
                <h2>Usage Examples</h2>
                <p>Just ask naturally:</p>
                <ul class="usage-examples">
                  <li>"Get my code-review prompt"</li>
                  <li>"Save this as my sql-helper prompt"</li>
                  <li>"List my testing prompts"</li>
                </ul>
              </section>

              <section class="troubleshooting-section">
                <h2>Troubleshooting</h2>
                <ul class="docs-list">
                  <li>Make sure Claude desktop is fully restarted after config changes</li>
                  <li>Check that your API key is valid in the LiminalDB dashboard</li>
                  <li>Verify the MCP server is installed globally with <code>which liminaldb-mcp</code></li>
                </ul>
              </section>
            </div>

            <!-- ChatGPT (Coming Soon) -->
            <div data-content="chatgpt" class="integration-guide" style="display: none;">
              <h1>ChatGPT Integration</h1>
              <div class="coming-soon-card">
                <span class="coming-soon-icon">üöß</span>
                <h3>Coming Soon</h3>
                <p>ChatGPT integration via custom GPT action is on the roadmap.</p>
                <p class="coming-soon-cta">Want to be notified when it's ready?</p>
                <button class="btn-secondary">Subscribe to updates</button>
              </div>
            </div>
          </div>
        </section>

        <!-- Tab: Code Editors -->
        <section id="tab-code-editors" class="tab-panel">
          <div class="integration-content">
            <!-- Claude Code -->
            <div data-content="claude-code" class="integration-guide">
              <h1>Claude Code Integration</h1>
              <p class="integration-intro">Claude Code has built-in MCP support. Add LiminalDB to any project in one command.</p>

              <section class="setup-section">
                <h2>Quick Setup</h2>

                <div class="setup-step">
                  <span class="step-number">1</span>
                  <div class="step-content">
                    <p>In your project directory:</p>
                    <div class="code-block">
                      <code>claude mcp add liminaldb</code>
                      <button class="copy-code-btn" title="Copy">Copy</button>
                    </div>
                  </div>
                </div>

                <p class="setup-done">That's it! Your prompts are now available.</p>
              </section>

              <div class="video-placeholder">
                <div class="video-icon">‚ñ∂</div>
                <span>Watch the setup walkthrough</span>
              </div>

              <section class="usage-section">
                <h2>Usage Examples</h2>
                <ul class="usage-examples">
                  <li>"Use my code-review prompt on this file"</li>
                  <li>"Get my commit-message prompt"</li>
                  <li>"Save this as my refactor-helper prompt"</li>
                </ul>
              </section>
            </div>

            <!-- Cursor -->
            <div data-content="cursor" class="integration-guide" style="display: none;">
              <h1>Cursor Integration</h1>
              <p class="integration-intro">Connect LiminalDB to Cursor via MCP.</p>

              <section class="setup-section">
                <h2>Setup Steps</h2>

                <div class="setup-step">
                  <span class="step-number">1</span>
                  <div class="step-content">
                    <p>Open Cursor Settings ‚Üí Features ‚Üí MCP</p>
                  </div>
                </div>

                <div class="setup-step">
                  <span class="step-number">2</span>
                  <div class="step-content">
                    <p>Add this server configuration:</p>
                    <div class="code-block">
<pre><code>{
  "liminaldb": {
    "command": "npx",
    "args": ["@liminaldb/mcp"],
    "env": {
      "LIMINALDB_API_KEY": "your-api-key"
    }
  }
}</code></pre>
                      <button class="copy-code-btn" title="Copy">Copy</button>
                    </div>
                  </div>
                </div>

                <div class="setup-step">
                  <span class="step-number">3</span>
                  <div class="step-content">
                    <p>Restart Cursor</p>
                  </div>
                </div>
              </section>

              <div class="video-placeholder">
                <div class="video-icon">‚ñ∂</div>
                <span>Watch the setup walkthrough</span>
              </div>
            </div>

            <!-- VS Code -->
            <div data-content="vscode" class="integration-guide" style="display: none;">
              <h1>VS Code Integration</h1>
              <p class="integration-intro">Use with any MCP-compatible VS Code extension.</p>

              <section class="setup-section">
                <h2>Recommended: Continue Extension</h2>

                <div class="setup-step">
                  <span class="step-number">1</span>
                  <div class="step-content">
                    <p>Install the Continue extension from marketplace</p>
                  </div>
                </div>

                <div class="setup-step">
                  <span class="step-number">2</span>
                  <div class="step-content">
                    <p>Open <code>.continue/config.json</code> and add:</p>
                    <div class="code-block">
<pre><code>{
  "mcpServers": [{
    "name": "liminaldb",
    "command": "npx @liminaldb/mcp"
  }]
}</code></pre>
                      <button class="copy-code-btn" title="Copy">Copy</button>
                    </div>
                  </div>
                </div>

                <div class="setup-step">
                  <span class="step-number">3</span>
                  <div class="step-content">
                    <p>Reload VS Code</p>
                  </div>
                </div>
              </section>

              <div class="video-placeholder">
                <div class="video-icon">‚ñ∂</div>
                <span>Watch the setup walkthrough</span>
              </div>
            </div>

            <!-- GitHub Copilot (Coming Soon) -->
            <div data-content="copilot" class="integration-guide" style="display: none;">
              <h1>GitHub Copilot Integration</h1>
              <div class="coming-soon-card">
                <span class="coming-soon-icon">üöß</span>
                <h3>Coming Soon</h3>
                <p>GitHub Copilot integration is on the roadmap.</p>
                <p class="coming-soon-cta">Want to be notified when it's ready?</p>
                <button class="btn-secondary">Subscribe to updates</button>
              </div>
            </div>
          </div>
        </section>

        <!-- Tab: Developer -->
        <section id="tab-developer" class="tab-panel">
          <div class="integration-content">
            <!-- REST API -->
            <div data-content="rest-api" class="integration-guide">
              <h1>REST API</h1>
              <p class="integration-intro">Full CRUD access to your prompt library via HTTP.</p>

              <section class="docs-section">
                <h2>Authentication</h2>
                <div class="code-block">
<pre><code>curl -H "Authorization: Bearer YOUR_API_KEY" \
  https://api.liminaldb.com/api/prompts</code></pre>
                  <button class="copy-code-btn" title="Copy">Copy</button>
                </div>
              </section>

              <section class="docs-section">
                <h2>Endpoints</h2>
                <table class="api-table">
                  <thead>
                    <tr>
                      <th>Method</th>
                      <th>Endpoint</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr><td>GET</td><td>/api/prompts</td><td>List prompts</td></tr>
                    <tr><td>GET</td><td>/api/prompts/:slug</td><td>Get prompt</td></tr>
                    <tr><td>POST</td><td>/api/prompts</td><td>Create prompt</td></tr>
                    <tr><td>PUT</td><td>/api/prompts/:slug</td><td>Update prompt</td></tr>
                    <tr><td>DELETE</td><td>/api/prompts/:slug</td><td>Delete prompt</td></tr>
                    <tr><td>GET</td><td>/api/tags</td><td>List tags</td></tr>
                  </tbody>
                </table>
              </section>

              <section class="docs-section">
                <h2>Query Parameters</h2>
                <ul class="docs-list">
                  <li><code>q</code> ‚Äî Full-text search</li>
                  <li><code>tags</code> ‚Äî Filter by tags (comma-separated)</li>
                </ul>
              </section>
            </div>

            <!-- SDK -->
            <div data-content="sdk" class="integration-guide" style="display: none;">
              <h1>SDK (Node.js)</h1>
              <p class="integration-intro">Programmatic access for applications.</p>

              <section class="docs-section">
                <h2>Install</h2>
                <div class="code-block">
                  <code>npm install @liminaldb/sdk</code>
                  <button class="copy-code-btn" title="Copy">Copy</button>
                </div>
                <p>or with Bun:</p>
                <div class="code-block">
                  <code>bun add @liminaldb/sdk</code>
                  <button class="copy-code-btn" title="Copy">Copy</button>
                </div>
              </section>

              <section class="docs-section">
                <h2>Usage</h2>
                <div class="code-block">
<pre><code>import { LiminalDB } from '@liminaldb/sdk';

const db = new LiminalDB({
  apiKey: process.env.LIMINALDB_API_KEY
});

// List prompts
const prompts = await db.prompts.list();

// Get by slug
const prompt = await db.prompts.get('code-review');

// Create
await db.prompts.create({
  slug: 'my-prompt',
  name: 'My Prompt',
  content: '...',
  tags: ['coding']
});</code></pre>
                  <button class="copy-code-btn" title="Copy">Copy</button>
                </div>
              </section>
            </div>

            <!-- CLI -->
            <div data-content="cli" class="integration-guide" style="display: none;">
              <h1>CLI</h1>
              <p class="integration-intro">Command-line interface for scripting and automation.</p>

              <section class="docs-section">
                <h2>Install</h2>
                <div class="code-block">
                  <code>npm install -g @liminaldb/cli</code>
                  <button class="copy-code-btn" title="Copy">Copy</button>
                </div>
              </section>

              <section class="docs-section">
                <h2>Commands</h2>
                <div class="code-block">
<pre><code># Authenticate
liminaldb auth login

# List prompts
liminaldb list
liminaldb list --tag code-review

# Get prompt content
liminaldb get code-review

# Create from file
liminaldb create --file my-prompt.md

# Sync local directory
liminaldb sync ./prompts/</code></pre>
                  <button class="copy-code-btn" title="Copy">Copy</button>
                </div>
              </section>
            </div>

            <!-- NPM / Bun Scripts -->
            <div data-content="scripts" class="integration-guide" style="display: none;">
              <h1>NPM / Bun Scripts</h1>
              <p class="integration-intro">Run LiminalDB commands without global install.</p>

              <section class="docs-section">
                <h2>One-off Commands</h2>
                <div class="code-block">
<pre><code># Using npx
npx @liminaldb/cli list
npx @liminaldb/cli get code-review

# Using bunx
bunx @liminaldb/cli list
bunx @liminaldb/cli get code-review</code></pre>
                  <button class="copy-code-btn" title="Copy">Copy</button>
                </div>
              </section>

              <section class="docs-section">
                <h2>Add to package.json</h2>
                <div class="code-block">
<pre><code>{
  "scripts": {
    "prompts": "liminaldb list",
    "prompts:sync": "liminaldb sync ./prompts"
  },
  "devDependencies": {
    "@liminaldb/cli": "^1.0.0"
  }
}</code></pre>
                  <button class="copy-code-btn" title="Copy">Copy</button>
                </div>
                <p>Then run:</p>
                <div class="code-block">
<pre><code>npm run prompts
bun run prompts:sync</code></pre>
                  <button class="copy-code-btn" title="Copy">Copy</button>
                </div>
              </section>
            </div>
          </div>
        </section>

        <!-- Tab: Help -->
        <section id="tab-help" class="tab-panel">
          <div class="docs-content">
            <h1>Help & Resources</h1>

            <section class="docs-section">
              <h2>Documentation</h2>
              <ul class="docs-list">
                <li><a href="#getting-started" class="help-link" data-tab="getting-started">Getting Started Guide</a></li>
                <li><a href="https://docs.liminaldb.com/api" target="_blank" rel="noopener">API Reference ‚Üó</a></li>
                <li><a href="https://docs.liminaldb.com/mcp" target="_blank" rel="noopener">MCP Integration Guide ‚Üó</a></li>
              </ul>
            </section>

            <section class="docs-section">
              <h2>Keyboard Shortcuts</h2>
              <table class="shortcuts-table">
                <tbody>
                  <tr><td><kbd>Cmd</kbd>+<kbd>K</kbd></td><td>Focus search</td></tr>
                  <tr><td><kbd>Cmd</kbd>+<kbd>N</kbd></td><td>New prompt</td></tr>
                  <tr><td><kbd>Escape</kbd></td><td>Clear selection</td></tr>
                </tbody>
              </table>
            </section>

            <section class="docs-section">
              <h2>FAQs</h2>

              <details class="faq-item">
                <summary>How are prompts ranked?</summary>
                <div class="faq-answer">
                  <p>Prompts are scored by:</p>
                  <ol>
                    <li>Pin status (pinned always first)</li>
                    <li>Usage frequency</li>
                    <li>Recency of use</li>
                    <li>Favorite status</li>
                  </ol>
                </div>
              </details>

              <details class="faq-item">
                <summary>What are the 19 shared tags?</summary>
                <div class="faq-answer">
                  <p>Tags are organized by dimension:</p>
                  <p><strong>Purpose:</strong> coding, writing, analysis, creative, planning, learning</p>
                  <p><strong>Domain:</strong> backend, frontend, data, devops, security, general</p>
                  <p><strong>Task:</strong> review, generate, explain, debug, refactor, document, test</p>
                </div>
              </details>

              <details class="faq-item">
                <summary>How long do drafts persist?</summary>
                <div class="faq-answer">
                  <p>Drafts are stored for 24 hours. They survive browser refresh and work across tabs.</p>
                </div>
              </details>
            </section>

            <section class="docs-section">
              <h2>Support</h2>
              <ul class="docs-list">
                <li>GitHub Issues: <a href="https://github.com/liminaldb/liminaldb" target="_blank" rel="noopener">github.com/liminaldb/liminaldb ‚Üó</a></li>
                <li>Email: <a href="mailto:support@liminaldb.com">support@liminaldb.com</a></li>
              </ul>
            </section>

            <section class="docs-section">
              <h2>Feedback</h2>
              <p>We'd love to hear from you! Use the feedback form or open a GitHub issue.</p>
            </section>
          </div>
        </section>
      </div>
    </div>

    <div id="empty-state" class="empty-state" style="display: none;">
      Select a prompt to view
    </div>

    <!-- Batch actions (visible when 2+ staging prompts) -->
    <div id="staging-header" class="staging-header" style="display: none;">
      <span class="staging-info">
        <span id="staging-count">0</span> prompt(s) to save
      </span>
      <div class="staging-actions">
        <button id="discard-all-btn" class="btn-secondary btn-sm">Discard All</button>
        <button id="save-all-btn" class="btn-primary btn-sm">Save All</button>
      </div>
    </div>

    <!-- Editor container (for new/edit modes) -->
    <div id="prompt-edit" class="prompt-edit" style="display: none;"></div>

    <article id="prompt-view" class="prompt-view" style="display: none;">
      <header class="prompt-header">
        <div class="prompt-header-top">
          <h1 id="prompt-slug" class="prompt-slug"></h1>
          <div class="prompt-header-controls">
            <button id="pin-toggle" class="icon-button" title="Pin prompt" aria-pressed="false">
              <span class="pin-icon"></span>
            </button>
            <button id="favorite-toggle" class="icon-button" title="Favorite prompt" aria-pressed="false">
              <span class="star-icon"></span>
            </button>
            <button id="edit-btn" class="btn-secondary btn-sm">Edit</button>
          </div>
        </div>
        <p id="prompt-description" class="prompt-description"></p>
      </header>

      <!-- Prompt Viewer Component -->
      <div class="prompt-viewer view-rendered" id="promptViewer">
        <div class="prompt-viewer-header">
          <button class="copy-btn-primary" id="copy-btn" title="Copy to clipboard">Copy</button>
          <div class="prompt-viewer-actions">
            <button class="prompt-viewer-btn active" data-view="rendered">Rendered</button>
            <button class="prompt-viewer-btn" data-view="semantic">Semantic</button>
            <button class="prompt-viewer-btn" data-view="plain">Plain</button>
            <span class="prompt-viewer-separator">|</span>
            <button class="prompt-viewer-btn" id="line-edit-toggle" title="Enable line-by-line editing">Line Edit</button>
          </div>
        </div>
        <!-- Draft expiration warning (hidden by default, shown by checkDraftExpiration) -->
        <div class="draft-expiry-warning" style="display: none;">
          <span class="warning-icon">‚ö†Ô∏è</span>
          <span class="warning-text">This draft will expire soon</span>
        </div>
        <div class="prompt-viewer-content" id="promptContent"></div>
        <div class="prompt-viewer-stats">
          <span class="prompt-viewer-stat">tags <span class="prompt-viewer-stat-value" id="statTags">0</span></span>
          <span class="prompt-viewer-stat">vars <span class="prompt-viewer-stat-value" id="statVars">0</span></span>
          <span class="prompt-viewer-stat">chars <span class="prompt-viewer-stat-value" id="statChars">0</span></span>
        </div>
      </div>
    </article>
  </main>

  <!-- Confirmation Modal -->
  <div id="confirm-modal" class="confirm-modal" style="display: none;">
    <div class="confirm-modal-content">
      <p id="confirm-message" class="confirm-message"></p>
      <div class="confirm-modal-actions">
        <button type="button" class="btn btn-secondary btn-sm" id="confirm-cancel">Cancel</button>
        <button type="button" class="btn btn-primary btn-sm" id="confirm-ok">OK</button>
      </div>
    </div>
  </div>

  <!-- Toast Container -->
  <div id="toast-container" class="toast-container"></div>

  <script src="/js/utils.js"></script>
  <script src="/js/components/modal.js"></script>
  <script src="/js/components/toast.js"></script>
  <script src="/js/components/tag-selector.js"></script>
  <script src="/js/components/prompt-viewer.js"></script>
  <script src="/js/components/prompt-editor.js"></script>
  <script>
    /**
     * @typedef {Object} DraftData
     * @property {string} slug
     * @property {string} name
     * @property {string} description
     * @property {string} content
     * @property {string[]} tags
     */

    /**
     * @typedef {Object} Draft
     * @property {string} draftId - Format: "edit:{slug}" or "new:{tempId}"
     * @property {'edit'|'new'} type
     * @property {string|null} promptSlug - Slug of prompt being edited (null for new)
     * @property {DraftData} data
     * @property {number} [createdAt]
     * @property {number} [updatedAt]
     * @property {number} [expiresAt]
     */

    // State
    let prompts = [];
    let selectedSlug = null;
    let currentMode = 'home'; // 'home' | 'view' | 'edit' | 'new'
    let currentView = 'rendered';
    let lineEditEnabled = false;
    let currentHomeTab = 'home';
    let currentSubItem = null; // Selected item within a tab (e.g., 'claude-ai')
    try {
      currentView = localStorage.getItem('promptViewMode') || 'rendered';
      lineEditEnabled = localStorage.getItem('lineEditEnabled') === 'true';
      currentHomeTab = localStorage.getItem('homeTab') || 'home';
    } catch (e) {
      // localStorage unavailable (private browsing, etc.)
    }
    let rawPrompt = '';
    let editingLineIndex = null; // Currently editing line index

    // Filter state tracking
    let currentQuery = '';
    let currentTags = [];

    // Integration nav data
    const integrationNavs = {
      'ai-assistants': [
        { id: 'claude-ai', name: 'Claude.ai', icon: 'ü§ñ' },
        { id: 'chatgpt', name: 'ChatGPT', badge: 'coming soon' }
      ],
      'code-editors': [
        { id: 'claude-code', name: 'Claude Code', icon: '‚ö°' },
        { id: 'cursor', name: 'Cursor', icon: 'üéØ' },
        { id: 'vscode', name: 'VS Code', icon: 'üíª' },
        { id: 'copilot', name: 'GitHub Copilot', badge: 'coming soon' }
      ],
      'developer': [
        { id: 'rest-api', name: 'REST API', icon: '{ }' },
        { id: 'sdk', name: 'SDK (Node.js)', icon: 'üì¶' },
        { id: 'cli', name: 'CLI', icon: '‚ñ∂Ô∏è' },
        { id: 'scripts', name: 'NPM / Bun Scripts', icon: 'üìú' }
      ]
    };

    // Current prompt flags (for optimistic updates)
    let currentPromptFlags = { pinned: false, favorited: false };

    // Staging state (insert mode)
    let stagingPrompts = []; // Array of { tempId, data: { slug, name, description, content, tags } }
    let selectedStagingId = null;
    let savedListState = { query: '', tags: [], scrollTop: 0 }; // Preserved during insert mode
    let isDirty = false;

    // Draft state
    let currentDraft = null;
    let draftDebounceTimer = null;
    const DRAFT_DEBOUNCE_MS = 500;
    const EXPIRY_WARNING_MS = 2 * 60 * 60 * 1000; // 2 hours

    // Initialize modal component (from modal.js)
    initModal();

    // ============================================
    // SHELL COMMUNICATION
    // ============================================

    /**
     * Notify shell of portlet state change for history tracking.
     * @param {Object} options
     * @param {boolean} options.trackHistory - Whether to add to browser history (default: true)
     */
    function notifyShellStateChange(trackHistory = true) {
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({
          type: 'history:push',
          state: {
            portlet: 'prompts',
            slug: selectedSlug,
            mode: currentMode
          },
          trackHistory
        }, window.location.origin);
      }
    }

    /**
     * Signal to shell that portlet is ready to receive state.
     */
    function notifyShellReady() {
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({ type: 'portlet:ready' }, window.location.origin);
      }
    }

    /**
     * Restore portlet state from shell (e.g., on back/forward navigation).
     * @param {Object} state - State object from shell
     */
    async function restoreState(state) {
      if (!state) return;

      if (state.slug && state.mode === 'view') {
        // Need to select the prompt - it might not be loaded yet
        if (prompts.length > 0) {
          selectPrompt(state.slug, { trackHistory: false });
        } else {
          // Prompts not loaded yet - store for after load
          selectedSlug = state.slug;
          currentMode = 'view';
        }
      } else if (state.slug && state.mode === 'edit') {
        // Edit mode - select prompt then enter edit mode
        if (prompts.length > 0) {
          selectPrompt(state.slug, { trackHistory: false });
          enterEditMode();
        } else {
          // Prompts not loaded yet - store for after load
          selectedSlug = state.slug;
          currentMode = 'edit';
        }
      } else if (state.mode === 'new') {
        // Insert mode - enter if not already in it
        if (currentMode !== 'new') {
          enterInsertMode();
        }
      } else if (state.mode === 'home' || state.mode === 'empty' || !state.slug) {
        enterHomeMode({ trackHistory: false });
      }
    }

    /**
     * Clear current selection and show home module.
     * @param {Object} options
     * @param {boolean} options.trackHistory - Whether to add to browser history
     */
    function clearSelection({ trackHistory = true } = {}) {
      enterHomeMode({ trackHistory });
    }

    // ============================================
    // HOME MODULE (Tab Navigation)
    // ============================================

    /**
     * Enter home mode - show the landing page with tabs
     * @param {Object} options
     * @param {boolean} options.trackHistory - Whether to add to browser history
     */
    function enterHomeMode({ trackHistory = true } = {}) {
      selectedSlug = null;
      currentMode = 'home';

      document.querySelectorAll(".prompt-item").forEach((item) => {
        item.classList.remove("selected");
      });

      const homeModule = document.getElementById("home-module");
      const emptyState = document.getElementById("empty-state");
      const promptView = document.getElementById("prompt-view");
      const promptEdit = document.getElementById("prompt-edit");

      if (homeModule) homeModule.classList.remove("hidden");
      if (emptyState) emptyState.style.display = "none";
      if (promptView) promptView.style.display = "none";
      if (promptEdit) promptEdit.style.display = "none";

      // Restore last active tab
      switchHomeTab(currentHomeTab);

      if (trackHistory) {
        notifyShellStateChange(true);
      }
    }

    /**
     * Switch between home tabs (non-history navigation)
     * @param {string} tabId - The tab to switch to
     */
    function switchHomeTab(tabId) {
      currentHomeTab = tabId;
      currentSubItem = null;

      // Update tab buttons
      document.querySelectorAll('.home-tab').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tab === tabId);
      });

      // Update panels
      document.querySelectorAll('.tab-panel').forEach(panel => {
        panel.classList.toggle('active', panel.id === `tab-${tabId}`);
      });

      // Update sidebar based on tab
      updateSidebarForTab(tabId);

      // Persist
      try {
        localStorage.setItem('homeTab', tabId);
      } catch (e) {}
    }

    /**
     * Update sidebar content based on active tab
     * @param {string} tabId - The active tab ID
     */
    function updateSidebarForTab(tabId) {
      const promptList = document.getElementById('prompt-list');
      const integrationNav = document.getElementById('integration-nav');
      const newPromptBtn = document.getElementById('new-prompt-btn');

      if (tabId === 'home') {
        // Show prompts list
        if (promptList) promptList.style.display = 'block';
        if (integrationNav) integrationNav.style.display = 'none';
        if (newPromptBtn) newPromptBtn.style.display = 'block';
      } else if (integrationNavs[tabId]) {
        // Show integration nav
        if (promptList) promptList.style.display = 'none';
        if (integrationNav) integrationNav.style.display = 'block';
        if (newPromptBtn) newPromptBtn.style.display = 'none';
        renderIntegrationNav(tabId);
        // Auto-select first item
        selectIntegrationItem(integrationNavs[tabId][0].id);
      } else {
        // Full-width content (getting-started, help)
        if (promptList) promptList.style.display = 'none';
        if (integrationNav) integrationNav.style.display = 'none';
        if (newPromptBtn) newPromptBtn.style.display = 'none';
      }
    }

    /**
     * Render the integration navigation items in sidebar
     * @param {string} tabId - The active tab ID
     */
    function renderIntegrationNav(tabId) {
      const nav = document.getElementById('integration-nav');
      const items = integrationNavs[tabId] || [];

      if (!nav) return;

      nav.innerHTML = items.map(item => `
        <div class="integration-nav-item" data-item="${item.id}">
          <span class="integration-nav-icon">${item.icon || ''}</span>
          <span class="integration-nav-name">${item.name}</span>
          ${item.badge ? `<span class="badge">${item.badge}</span>` : ''}
        </div>
      `).join('');

      // Attach click handlers
      nav.querySelectorAll('.integration-nav-item').forEach(el => {
        el.addEventListener('click', () => {
          selectIntegrationItem(el.dataset.item);
        });
      });
    }

    /**
     * Select an item in the integration nav
     * @param {string} itemId - The item to select
     */
    function selectIntegrationItem(itemId) {
      currentSubItem = itemId;

      // Update nav selection
      document.querySelectorAll('.integration-nav-item').forEach(el => {
        el.classList.toggle('selected', el.dataset.item === itemId);
      });

      // Update content panel
      updateIntegrationContent(currentHomeTab, itemId);
    }

    /**
     * Show/hide integration content based on selected item
     * @param {string} tabId - The active tab ID
     * @param {string} itemId - The selected item ID
     */
    function updateIntegrationContent(tabId, itemId) {
      const panel = document.getElementById(`tab-${tabId}`);
      if (!panel) return;

      // Content is pre-rendered in HTML, we just show/hide the right section
      panel.querySelectorAll('[data-content]').forEach(el => {
        el.style.display = el.dataset.content === itemId ? 'block' : 'none';
      });
    }

    // ============================================
    // INSERT MODE (Staging)
    // ============================================

    /**
     * Generate a temporary ID for staging prompts
     */
    function generateTempId() {
      return 'temp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    /**
     * Enter insert mode - add a new prompt to staging
     */
    async function enterInsertMode() {
      // Capture current form data before creating new entry
      if (selectedStagingId) {
        const current = stagingPrompts.find(s => s.tempId === selectedStagingId);
        if (current) {
          current.data = promptEditor.getFormData();
        }
      }

      // If first insert, save current list state
      if (stagingPrompts.length === 0) {
        const listEl = document.getElementById('prompt-list');
        savedListState = {
          query: '', // Will be populated by shell filter state if needed
          tags: [],
          scrollTop: listEl ? listEl.scrollTop : 0
        };
      }

      // Create new staging prompt
      const newPrompt = {
        tempId: generateTempId(),
        data: {
          slug: '',
          name: 'New Prompt',
          description: '',
          content: '',
          tags: []
        }
      };

      stagingPrompts.push(newPrompt);
      selectedStagingId = newPrompt.tempId;
      currentMode = 'new';

      renderStagingList();
      await showEditor(newPrompt.data);
      isDirty = false; // Reset after showing new empty form
      updateStagingFooter();
      notifyShellStateChange(true);
      
      // Create draft entry for new prompt
      handleNewPrompt();
      // Note: notifyShellOfDrafts() will be called from saveToDraft() in green phase
    }

    /**
     * Enter edit mode for an existing prompt
     */
    async function enterEditMode() {
      if (!selectedSlug) return;

      const prompt = prompts.find(p => p.slug === selectedSlug);
      if (!prompt) return;

      currentMode = 'edit';
      await showEditor(prompt);
      notifyShellStateChange(true);
    }

    /**
     * Show the editor with given data
     */
    async function showEditor(data) {
      const homeModule = document.getElementById('home-module');
      const emptyState = document.getElementById('empty-state');
      const promptView = document.getElementById('prompt-view');
      const promptEdit = document.getElementById('prompt-edit');

      if (homeModule) homeModule.classList.add('hidden');
      if (emptyState) emptyState.style.display = 'none';
      if (promptView) promptView.style.display = 'none';
      if (promptEdit) promptEdit.style.display = 'block';

      await promptEditor.init(promptEdit, {
        data,
        onSave: handleSave,
        onDiscard: handleDiscard,
        onDirtyChange: (dirty) => {
          isDirty = dirty;
          notifyShellDirtyState(dirty);
        },
        onChange: (field, value) => {
          handleEditModeChange(field, value);
        }
      });
    }

    /**
     * Hide the editor and show appropriate view
     */
    function hideEditor() {
      const promptEdit = document.getElementById('prompt-edit');
      if (promptEdit) promptEdit.style.display = 'none';

      promptEditor.destroy();
      isDirty = false;
      notifyShellDirtyState(false);
    }

    /**
     * Notify shell of dirty state for confirmation prompts
     */
    function notifyShellDirtyState(dirty) {
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({
          type: 'portlet:dirty',
          dirty
        }, window.location.origin);
      }
    }

    /**
     * Render the staging list in the sidebar
     */
    function renderStagingList() {
      const listEl = document.getElementById('prompt-list');
      if (!listEl) return;

      listEl.innerHTML = '';

      stagingPrompts.forEach((staging) => {
        const item = document.createElement('div');
        item.className = 'prompt-item staging';
        item.dataset.tempId = staging.tempId;

        if (staging.tempId === selectedStagingId) {
          item.classList.add('selected');
        }

        const name = staging.data.name || 'New Prompt';
        const slug = staging.data.slug || '(no slug)';

        item.innerHTML = `
          <div class="prompt-name">${escapeHtml(name)}</div>
          <div class="prompt-slug">${escapeHtml(slug)}</div>
          <div class="item-status">unsaved</div>
          <button class="btn-icon remove-staging" title="Remove">√ó</button>
        `;

        item.addEventListener('click', (e) => {
          if (e.target.classList.contains('remove-staging')) {
            removeStagingPrompt(staging.tempId);
          } else {
            selectStagingPrompt(staging.tempId);
          }
        });

        listEl.appendChild(item);
      });

      // Update staging header visibility
      updateStagingFooter();
    }

    /**
     * Select a staging prompt
     */
    async function selectStagingPrompt(tempId) {
      // Check dirty state first
      if (isDirty && selectedStagingId !== tempId) {
        if (!await showConfirm('Discard unsaved changes?')) return;
      }

      // Save current editor state back to staging
      if (selectedStagingId) {
        const current = stagingPrompts.find(s => s.tempId === selectedStagingId);
        if (current) {
          current.data = promptEditor.getFormData();
        }
      }

      selectedStagingId = tempId;
      const staging = stagingPrompts.find(s => s.tempId === tempId);
      if (staging) {
        await showEditor(staging.data);
      }

      renderStagingList();
    }

    /**
     * Remove a prompt from staging
     */
    async function removeStagingPrompt(tempId) {
      if (isDirty && tempId === selectedStagingId) {
        if (!await showConfirm('Discard unsaved changes?')) return;
      }

      stagingPrompts = stagingPrompts.filter(s => s.tempId !== tempId);

      if (stagingPrompts.length === 0) {
        await exitInsertMode();
      } else if (selectedStagingId === tempId) {
        // Select the first remaining
        selectedStagingId = stagingPrompts[0].tempId;
        await showEditor(stagingPrompts[0].data);
        renderStagingList();
      } else {
        renderStagingList();
      }

      updateStagingFooter();
    }

    /**
     * Update staging header visibility and count
     * Only shows when 2+ prompts are staged
     */
    function updateStagingFooter() {
      const header = document.getElementById('staging-header');
      const countEl = document.getElementById('staging-count');
      if (countEl) countEl.textContent = stagingPrompts.length;
      if (header) {
        header.style.display = stagingPrompts.length >= 2 ? 'flex' : 'none';
      }
    }

    /**
     * Exit insert mode and restore list
     */
    async function exitInsertMode() {
      stagingPrompts = [];
      selectedStagingId = null;
      hideEditor();

      const header = document.getElementById('staging-header');
      if (header) header.style.display = 'none';

      // Restore list (loadPrompts handles empty states internally)
      await loadPrompts(savedListState.query, savedListState.tags);

      // Restore scroll position
      const listEl = document.getElementById('prompt-list');
      if (listEl) listEl.scrollTop = savedListState.scrollTop;

      currentMode = 'empty';
      clearSelection({ trackHistory: true });
    }

    /**
     * Handle save from editor
     */
    async function handleSave(data) {
      try {
        if (currentMode === 'edit') {
          // Update existing prompt
          const response = await fetch(`/api/prompts/${selectedSlug}`, {
            method: 'PUT',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify(data)
          });

          if (!response.ok) {
            const err = await response.json();
            handleSaveFailure(err);
            showToast(err.error || 'Failed to save', { type: 'error' });
            return;
          }

          // Commit draft to Convex (delete draft after successful save)
          commitDraftToConvex();
          
          hideEditor();
          await loadPrompts();

          // If slug changed, select new slug
          selectPrompt(data.slug, { trackHistory: true });
        } else if (currentMode === 'new') {
          // Create new prompt
          const response = await fetch('/api/prompts', {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ prompts: [data] })
          });

          if (!response.ok) {
            const err = await response.json();
            handleSaveFailure(err);
            showToast(err.error || 'Failed to save', { type: 'error' });
            return;
          }

          // Commit draft to Convex (delete draft after successful save)
          commitDraftToConvex();

          // Remove from staging
          stagingPrompts = stagingPrompts.filter(s => s.tempId !== selectedStagingId);

          if (stagingPrompts.length === 0) {
            await exitInsertMode();
            // Select the newly created prompt
            await loadPrompts();
            selectPrompt(data.slug, { trackHistory: true });
          } else {
            // More to save - select next
            selectedStagingId = stagingPrompts[0].tempId;
            await showEditor(stagingPrompts[0].data);
            renderStagingList();
            updateStagingFooter();
          }
        }
      } catch (err) {
        console.error('Save failed:', err);
        handleSaveFailure(err);
        showToast('Failed to save prompt', { type: 'error' });
      }
    }

    /**
     * Handle discard from editor
     */
    function handleDiscard() {
      // Clear draft from Redis
      clearDraftFromRedis();
      
      if (currentMode === 'edit') {
        hideEditor();
        currentMode = 'view';
        // Re-show the view
        const emptyState = document.getElementById('empty-state');
        const promptView = document.getElementById('prompt-view');
        if (emptyState) emptyState.style.display = 'none';
        if (promptView) promptView.style.display = 'block';
        notifyShellStateChange(true);
      } else if (currentMode === 'new') {
        removeStagingPrompt(selectedStagingId);
      }
    }

    /**
     * Save all staging prompts
     */
    async function saveAll() {
      if (stagingPrompts.length === 0) return;

      // Update current editor data
      if (selectedStagingId) {
        const current = stagingPrompts.find(s => s.tempId === selectedStagingId);
        if (current) {
          current.data = promptEditor.getFormData();
        }
      }

      // Validate current prompt with inline errors
      const errors = promptEditor.validate();
      if (Object.keys(errors).length > 0) {
        // Trigger the save button to show inline errors
        const saveBtn = document.getElementById('btn-save');
        if (saveBtn) saveBtn.click();
        return;
      }

      // Validate all staged prompts
      const promptsToSave = stagingPrompts.map(s => s.data);
      for (let i = 0; i < promptsToSave.length; i++) {
        const data = promptsToSave[i];
        if (!data.slug || !data.name || !data.description || !data.content) {
          // Find the staging prompt with issues and switch to it
          const staging = stagingPrompts[i];
          if (staging.tempId !== selectedStagingId) {
            await selectStagingPrompt(staging.tempId);
            showToast('This prompt has missing required fields', { type: 'error' });
          }
          return;
        }
      }

      try {
        const response = await fetch('/api/prompts', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ prompts: promptsToSave })
        });

        if (!response.ok) {
          const err = await response.json();
          showToast(err.error || 'Failed to save', { type: 'error' });
          return;
        }

        await exitInsertMode();
        // Select first created prompt
        await loadPrompts();
        if (promptsToSave.length > 0) {
          selectPrompt(promptsToSave[0].slug, { trackHistory: true });
        }
      } catch (err) {
        console.error('Save all failed:', err);
        showToast('Failed to save prompts', { type: 'error' });
      }
    }

    /**
     * Discard all staging prompts
     */
    async function discardAll() {
      if (stagingPrompts.length === 0) return;

      if (!await showConfirm(`Discard all ${stagingPrompts.length} unsaved prompt(s)?`)) return;

      await exitInsertMode();
    }

    // Initialize view mode from localStorage
    function initViewMode() {
      const viewer = document.getElementById('promptViewer');
      viewer.className = `prompt-viewer view-${currentView}`;
      viewer.querySelectorAll('[data-view]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.view === currentView);
      });
    }

    // Display prompt content with current view mode
    function displayPromptContent(content) {
      rawPrompt = content;
      const contentEl = document.getElementById('promptContent');

      // Only enable line edit in semantic/plain views, not rendered
      const effectiveLineEdit = lineEditEnabled && currentView !== 'rendered';
      const { html, stats } = renderPrompt(content, currentView, { lineEdit: effectiveLineEdit });
      contentEl.innerHTML = html || '<span style="color: var(--text-muted)">No content</span>';

      document.getElementById('statTags').textContent = stats.tags;
      document.getElementById('statVars').textContent = stats.vars;
      document.getElementById('statChars').textContent = content.length;

      // Set up line edit click handlers if enabled and not in rendered view
      if (effectiveLineEdit) {
        setupLineEditHandlers();
      }
    }

    // ============================================
    // LINE EDIT MODE
    // ============================================

    /**
     * Initialize line edit toggle state
     */
    function initLineEditMode() {
      const toggle = document.getElementById('line-edit-toggle');
      if (!toggle) return;

      toggle.classList.toggle('active', lineEditEnabled);
      const viewer = document.getElementById('promptViewer');
      if (viewer) {
        viewer.classList.toggle('line-edit-mode', lineEditEnabled);
      }
    }

    /**
     * Toggle line edit mode (disabled in rendered view)
     */
    function toggleLineEdit() {
      // Line edit not available in rendered view
      if (currentView === 'rendered') return;

      lineEditEnabled = !lineEditEnabled;

      try {
        localStorage.setItem('lineEditEnabled', lineEditEnabled.toString());
      } catch (e) {
        // localStorage unavailable
      }

      const toggle = document.getElementById('line-edit-toggle');
      if (toggle) toggle.classList.toggle('active', lineEditEnabled);

      const viewer = document.getElementById('promptViewer');
      if (viewer) viewer.classList.toggle('line-edit-mode', lineEditEnabled);

      // Re-render content with new mode
      if (rawPrompt) {
        displayPromptContent(rawPrompt);
      }
    }

    /**
     * Update line edit toggle availability based on view mode
     */
    function updateLineEditAvailability() {
      const toggle = document.getElementById('line-edit-toggle');
      if (!toggle) return;

      if (currentView === 'rendered') {
        // Disable line edit in rendered view
        toggle.disabled = true;
        toggle.classList.remove('active');
        toggle.title = 'Line edit not available in Rendered view';

        const viewer = document.getElementById('promptViewer');
        if (viewer) viewer.classList.remove('line-edit-mode');
      } else {
        // Enable line edit in plain/semantic views
        toggle.disabled = false;
        toggle.title = 'Enable line-by-line editing';

        // Restore saved state
        if (lineEditEnabled) {
          toggle.classList.add('active');
          const viewer = document.getElementById('promptViewer');
          if (viewer) viewer.classList.add('line-edit-mode');
        }
      }
    }

    /**
     * Set up click handlers for editable lines
     */
    function setupLineEditHandlers() {
      const contentEl = document.getElementById('promptContent');
      if (!contentEl) return;

      contentEl.querySelectorAll('.editable-line').forEach(lineEl => {
        lineEl.addEventListener('click', (e) => {
          // Don't trigger if clicking on an existing input
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

          const lineIndex = parseInt(lineEl.dataset.line, 10);
          startLineEdit(lineIndex, lineEl);
        });
      });
    }

    /**
     * Start editing a specific line
     */
    function startLineEdit(lineIndex, lineEl) {
      // If already editing another line, save it first
      if (editingLineIndex !== null && editingLineIndex !== lineIndex) {
        saveCurrentLineEdit();
      }

      editingLineIndex = lineIndex;
      const lines = rawPrompt.split('\n');
      const lineContent = lines[lineIndex] || '';

      // Create inline input
      const input = document.createElement('textarea');
      input.className = 'line-edit-input';
      input.value = lineContent;
      input.rows = 1;

      // Auto-resize based on content
      input.style.width = '100%';
      input.style.minWidth = Math.max(lineEl.offsetWidth, 300) + 'px';

      // Replace line content with input
      lineEl.innerHTML = '';
      lineEl.appendChild(input);
      lineEl.classList.add('editing');

      // Focus and select all
      input.focus();
      input.select();

      // Auto-resize height
      const autoResize = () => {
        input.style.height = 'auto';
        input.style.height = input.scrollHeight + 'px';
      };
      input.addEventListener('input', autoResize);
      autoResize();

      // Save on blur
      input.addEventListener('blur', () => {
        saveLineEdit(lineIndex, input.value);
      });

      // Save on Enter (Shift+Enter for newline would need multiline support)
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          input.blur(); // Triggers save via blur handler
        }
        if (e.key === 'Escape') {
          e.preventDefault();
          editingLineIndex = null;
          displayPromptContent(rawPrompt); // Re-render without saving
        }
      });
    }

    /**
     * Save the currently editing line
     */
    function saveCurrentLineEdit() {
      const contentEl = document.getElementById('promptContent');
      if (!contentEl || editingLineIndex === null) return;

      const editingEl = contentEl.querySelector('.editable-line.editing');
      if (!editingEl) return;

      const input = editingEl.querySelector('.line-edit-input');
      if (input) {
        saveLineEdit(editingLineIndex, input.value);
      }
    }

    /**
     * Save a line edit and update the prompt
     */
    async function saveLineEdit(lineIndex, newValue) {
      const lines = rawPrompt.split('\n');
      const oldValue = lines[lineIndex] || '';
      const contentEl = document.getElementById('promptContent');
      const lineEl = contentEl?.querySelector(`.editable-line[data-line="${lineIndex}"]`);

      // No change, just re-render
      if (newValue === oldValue) {
        editingLineIndex = null;
        if (lineEl) {
          lineEl.classList.remove('editing');
          lineEl.textContent = oldValue;
        } else {
          displayPromptContent(rawPrompt);
        }
        return;
      }

      // Update local content
      lines[lineIndex] = newValue;
      const newContent = lines.join('\n');

      // Get current prompt data
      const prompt = prompts.find(p => p.slug === selectedSlug);
      if (!prompt) {
        editingLineIndex = null;
        if (lineEl) {
          lineEl.classList.remove('editing');
          lineEl.textContent = oldValue;
        } else {
          displayPromptContent(rawPrompt);
        }
        return;
      }

      // Save to draft (line edit ‚Üí draft, not immediate save)
      handleLineEdit('content', newContent);

      // Do NOT write through to /api/prompts here. Line edits are draft-only until explicit Save.
      prompt.content = newContent;
      rawPrompt = newContent;
      editingLineIndex = null;

      if (lineEl) {
        lineEl.classList.remove('editing');
        lineEl.textContent = newValue;
      } else {
        displayPromptContent(newContent);
      }
    }

    // Load prompts on init
    async function loadPrompts(query = '', tags = []) {
      currentQuery = query;
      currentTags = tags;

      const params = new URLSearchParams();
      const trimmed = query.trim();
      if (trimmed) {
        params.set('q', trimmed);
      }
      if (tags.length > 0) {
        params.set('tags', tags.join(','));
      }

      const queryString = params.toString();
      const url = queryString ? `/api/prompts?${queryString}` : "/api/prompts";

      try {
        const response = await fetch(url, {
          method: "GET",
          headers: { "content-type": "application/json" },
        });

        if (!response.ok) {
          throw new Error('Failed to load prompts');
        }

        const data = await response.json();
        prompts = Array.isArray(data) ? data : [];

        if (prompts.length === 0) {
          if (currentQuery || currentTags.length > 0) {
            renderEmptyState('no-matches');
          } else {
            renderEmptyState('no-prompts');
          }
        } else {
          renderPromptList(prompts);
        }

        if (selectedSlug) {
          const stillExists = prompts.some((prompt) => prompt.slug === selectedSlug);
          if (stillExists) {
            selectPrompt(selectedSlug, { trackHistory: false });
          }
        }
      } catch (err) {
        console.error('Filter failed:', err);
        showToast('Failed to filter prompts', { type: 'error' });
      }
    }


    // Render prompt list with proper pin/star indicators
    function renderPromptList(prompts) {
      const list = document.getElementById('prompt-list');
      const emptyState = document.getElementById('empty-state');

      if (!list) return;

      list.innerHTML = '';
      if (emptyState) emptyState.style.display = 'none';

      prompts.forEach((prompt) => {
        const item = renderPromptListItem(prompt);
        list.appendChild(item);
      });
    }

    function renderPromptListItem(prompt) {
      const item = document.createElement('div');
      item.className = 'prompt-item';
      item.dataset.slug = prompt.slug;

      if (prompt.slug === selectedSlug) {
        item.classList.add('selected');
      }

      const tagsHtml = (prompt.tags || [])
        .map((tag) => `<span class="tag">${escapeHtml(tag)}</span>`)
        .join(" ");

      // Use .prompt-pin and .prompt-star classes (test hooks)
      const pinIndicator = prompt.pinned
        ? '<span class="prompt-pin" title="Pinned">üìå</span>'
        : '<span class="prompt-pin" style="display:none">üìå</span>';

      const favoriteIndicator = prompt.favorited
        ? '<span class="prompt-star" title="Favorited">‚≠ê</span>'
        : '<span class="prompt-star" style="display:none">‚≠ê</span>';

      item.innerHTML = `
        <div class="prompt-name">${escapeHtml(prompt.name)}</div>
        <div class="prompt-slug">${escapeHtml(prompt.slug)}</div>
        <div class="prompt-tags">${tagsHtml}</div>
        <div class="prompt-indicators">
          ${pinIndicator}
          ${favoriteIndicator}
        </div>
      `;

      item.addEventListener('click', () => selectPrompt(prompt.slug));
      return item;
    }

    // Select prompt
    function selectPrompt(slug, { trackHistory = true } = {}) {
      const prompt = prompts.find((item) => item.slug === slug);
      if (!prompt) {
        return;
      }

      selectedSlug = slug;
      currentMode = 'view';

      document.querySelectorAll(".prompt-item").forEach((item) => {
        if (item.dataset.slug === slug) {
          item.classList.add("selected");
        } else {
          item.classList.remove("selected");
        }
      });

      // Hide home module and show prompt view
      const homeModule = document.getElementById("home-module");
      const emptyState = document.getElementById("empty-state");
      const promptView = document.getElementById("prompt-view");
      if (homeModule) homeModule.classList.add("hidden");
      if (emptyState) emptyState.style.display = "none";
      if (promptView) promptView.style.display = "block";

      // Restore sidebar to show prompt list
      const promptList = document.getElementById('prompt-list');
      const integrationNav = document.getElementById('integration-nav');
      const newPromptBtn = document.getElementById('new-prompt-btn');
      if (promptList) promptList.style.display = 'block';
      if (integrationNav) integrationNav.style.display = 'none';
      if (newPromptBtn) newPromptBtn.style.display = 'block';

      const slugEl = document.getElementById("prompt-slug");
      const descEl = document.getElementById("prompt-description");
      if (slugEl) slugEl.textContent = prompt.slug;
      if (descEl) descEl.textContent = prompt.description;

      // Update current prompt flags
      currentPromptFlags = {
        pinned: prompt.pinned ?? false,
        favorited: prompt.favorited ?? false,
      };

      // Update pin/favorite toggle states
      updatePinUI(slug, currentPromptFlags.pinned);
      updateFavoriteUI(slug, currentPromptFlags.favorited);

      // Use prompt viewer to display content
      displayPromptContent(prompt.content || '');

      // Notify shell for history tracking
      if (trackHistory) {
        notifyShellStateChange(true);
      }
    }

    // Copy to clipboard
    async function copyContent() {
      if (!rawPrompt) return;

      try {
        await navigator.clipboard.writeText(rawPrompt);
        const copyBtn = document.getElementById("copy-btn");
        if (!copyBtn) return;
        const originalText = copyBtn.textContent;
        copyBtn.textContent = "‚úì Copied!";
        copyBtn.classList.add("copied");
        setTimeout(() => {
          copyBtn.textContent = originalText;
          copyBtn.classList.remove("copied");
        }, 1200);

        // Track usage after successful copy
        if (selectedSlug) {
          fetch(`/api/prompts/${selectedSlug}/usage`, {
            method: "POST",
            keepalive: true,
          }).catch(() => {}); // fire-and-forget
        }
      } catch (err) {
        console.error('Failed to copy:', err);
      }
    }

    // View toggle buttons
    document.getElementById('promptViewer').querySelectorAll('[data-view]').forEach(btn => {
      btn.addEventListener('click', () => {
        const viewer = document.getElementById('promptViewer');
        viewer.querySelectorAll('[data-view]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentView = btn.dataset.view;
        try {
          localStorage.setItem('promptViewMode', currentView);
        } catch (e) {
          // localStorage unavailable (private browsing, etc.)
        }
        viewer.className = `prompt-viewer view-${currentView}`;
        updateLineEditAvailability();
        if (rawPrompt) displayPromptContent(rawPrompt);
      });
    });

    // ============================================
    // DRAFT MANAGEMENT
    // ============================================

    /**
     * Draft ID patterns:
     * - Edit mode: "edit:${slug}" (e.g., "edit:code-review")
     * - New mode: "new:${tempId}" (e.g., "new:temp_1234567890_abc123")
     * - Line edit: "edit:${slug}" (same as edit mode, accumulates changes)
     */

    /**
     * Auto-save to draft on edit mode changes
     * Debounced to avoid excessive API calls.
     */
    function handleEditModeChange(field, value) {
      clearTimeout(draftDebounceTimer);
      draftDebounceTimer = setTimeout(() => {
        saveToDraft();
      }, DRAFT_DEBOUNCE_MS);
    }

    /**
     * Save current state to draft
     * 
     * Draft ID format:
     * - Edit mode: "edit:${selectedSlug}"
     * - New mode: "new:${selectedStagingId}"
     * 
     * Draft data structure:
     * {
     *   type: "edit" | "new",
     *   promptSlug: string | undefined,
     *   data: { slug, name, description, content, tags }
     * }
     *
     * API: PUT /api/drafts/:draftId
     */

    /**
     * Get the draft ID for the current editing context.
     * @returns {string|null} Draft ID in format "edit:{slug}" or "new:{tempId}", or null if not in draft context
     */
    function getDraftIdForCurrentContext() {
      if (currentDraft?.draftId) return currentDraft.draftId;
      if (currentMode === 'edit' && selectedSlug) return `edit:${selectedSlug}`;
      if (currentMode === 'new') return `new:${selectedStagingId || generateTempId()}`;
      // Line edits in view mode should also be saved under edit:${slug}
      if (currentMode === 'view' && selectedSlug) return `edit:${selectedSlug}`;
      return null;
    }

    /**
     * Get the draft type for the current editing context.
     * @returns {'edit'|'new'} The draft type
     */
    function getDraftTypeForCurrentContext() {
      if (currentDraft?.type) return currentDraft.type;
      if (currentMode === 'new') return 'new';
      return 'edit';
    }

    async function fetchDraftSummaryForShell() {
      if (typeof fetch !== 'function') return null;
      try {
        const response = await fetch('/api/drafts/summary', { credentials: 'same-origin' });
        if (!response.ok) return null;
        return await response.json();
      } catch {
        return null;
      }
    }

    /**
     * Save current editor state to draft storage.
     * @param {Partial<Draft>|null} [override] - Optional override for draft properties
     * @returns {Promise<void>}
     */
    async function saveToDraft(override = null) {
      if (typeof fetch !== 'function') return;
      const draftId = override?.draftId || getDraftIdForCurrentContext();
      if (!draftId) return;

      const type = override?.type || getDraftTypeForCurrentContext();
      const promptSlug = override?.promptSlug ?? selectedSlug;
      let data = override?.data || null;
      if (!data) {
        // Editor may not be mounted anymore (e.g., navigation/discard) ‚Äî bail safely.
        try {
          if (typeof promptEditor !== 'undefined' && promptEditor.getFormData) {
            data = promptEditor.getFormData();
          }
        } catch {
          return;
        }
      }
      if (!data) return;

      const payload = {
        type,
        promptSlug,
        data,
      };

      try {
        const response = await fetch(`/api/drafts/${draftId}`, {
          method: 'PUT',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify(payload),
        });

        // Do not throw on non-OK (tests only care that fetch is called)
        if (response.ok) {
          const saved = await response.json();
          currentDraft = { ...payload, ...saved, draftId };
          // Only fetch summary + notify when embedded in the shell.
          if (window.parent && window.parent !== window) {
            const summary = await fetchDraftSummaryForShell();
            if (summary) notifyShellOfDrafts(summary);
          }
        } else {
          // Preserve local draft id even if server rejected, to avoid losing work
          currentDraft = { ...payload, draftId };
        }
      } catch (err) {
        console.error('Draft save failed:', err);
        currentDraft = { ...payload, draftId };
      }
    }

    /**
     * Line edit ‚Üí draft (not immediate save)
     * 
     * Note: Line edits create/update drafts but don't immediately save to Convex.
     * The draft accumulates changes until user clicks Save.
     * 
     * Draft ID: "edit:${selectedSlug}"
     */
    function handleLineEdit(field, value) {
      if (!selectedSlug) return;
      const prompt = prompts.find(p => p.slug === selectedSlug);
      if (!prompt) return;

      const updated = {
        slug: prompt.slug,
        name: prompt.name,
        description: prompt.description,
        content: prompt.content,
        tags: prompt.tags || [],
      };
      updated[field] = value;

      // Ensure line edits all accumulate into the same draft for a slug
      const draftId = `edit:${selectedSlug}`;
      currentDraft = { draftId, type: 'edit', promptSlug: selectedSlug, data: updated };

      // Line edits should persist quickly so refresh doesn't lose them.
      // Tests expect this to happen without waiting for the full debounce window.
      clearTimeout(draftDebounceTimer);
      saveToDraft({ draftId, type: 'edit', promptSlug: selectedSlug, data: updated });
    }

    /**
     * +New creates draft entry
     * 
     * Draft ID: "new:${selectedStagingId}"
     */
    function handleNewPrompt() {
      // When entering insert mode we create an initial draft immediately
      const draftId = `new:${selectedStagingId || generateTempId()}`;
      let data = null;
      try {
        data = promptEditor.getFormData();
      } catch {
        return;
      }
      currentDraft = { draftId, type: 'new', promptSlug: null, data };
      // Immediate save (no debounce) so multiple +New produces multiple drafts
      saveToDraft({ draftId, type: 'new', promptSlug: null, data });
    }

    /**
     * Save button commits draft to Convex
     * 
     * After successful save to Convex, deletes the draft from Redis.
     * API: DELETE /api/drafts/:draftId
     */
    function commitDraftToConvex() {
      if (typeof fetch !== 'function') return;
      const draftId = getDraftIdForCurrentContext();
      if (!draftId) return;
      // Fire-and-forget: save flow already succeeded; deleting draft shouldn't block UI
      fetch(`/api/drafts/${draftId}`, {
        method: 'DELETE',
        credentials: 'same-origin',
      })
        .then(async (res) => {
          if (res.ok) {
            currentDraft = null;
            const summary = await fetchDraftSummaryForShell();
            if (summary) notifyShellOfDrafts(summary);
          }
        })
        .catch(() => {});
    }

    /**
     * Discard button clears draft from Redis
     *
     * API: DELETE /api/drafts/:draftId
     */
    function clearDraftFromRedis() {
      if (typeof fetch !== 'function') return;
      const draftId = getDraftIdForCurrentContext();
      if (!draftId) return;
      fetch(`/api/drafts/${draftId}`, {
        method: 'DELETE',
        credentials: 'same-origin',
      })
        .then(async (res) => {
          if (res.ok) {
            currentDraft = null;
            const summary = await fetchDraftSummaryForShell();
            if (summary) notifyShellOfDrafts(summary);
          }
        })
        .catch((err) => console.warn('Draft cleanup failed:', err));
    }

    /**
     * Save failure preserves draft
     * 
     * When save fails, draft remains in Redis for recovery.
     */
    function handleSaveFailure(error) {
      // Intentionally do not delete the draft on save failure.
      console.error('Save failed:', error);
    }

    /**
     * Check draft expiration and show warning if expiring soon.
     * Shows warning when draft expires within 2 hours.
     *
     * @param {Draft} draft - The draft object to check for expiration
     * @returns {void}
     */
    function checkDraftExpiration(draft) {
      const warningEl = document.querySelector('.draft-expiry-warning');
      if (!warningEl) return;
      if (!draft || typeof draft.expiresAt !== 'number') {
        warningEl.style.display = 'none';
        return;
      }
      const remaining = draft.expiresAt - Date.now();
      warningEl.style.display = remaining < EXPIRY_WARNING_MS ? 'block' : 'none';
    }

    /**
     * Notify shell of draft changes.
     * Sends draft summary to shell for indicator updates.
     * Called after draft create/update/delete operations.
     *
     * @param {{count: number, latestDraftId: string|null, nextExpiryAt?: number, hasExpiringSoon: boolean}} summary - Draft summary from API
     * @returns {void}
     */
    function notifyShellOfDrafts(summary) {
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({
          type: 'portlet:drafts',
          count: summary.count,
          latestDraftId: summary.latestDraftId,
          nextExpiryAt: summary.nextExpiryAt,
          hasExpiringSoon: summary.hasExpiringSoon
        }, window.location.origin);
      }
    }

    /**
     * Open draft from shell request.
     * Fetches draft list from API and finds matching draft, then restores the editor state.
     *
     * @param {string} draftId - Draft ID in format "edit:{slug}" or "new:{tempId}"
     * @returns {Promise<void>}
     */
    async function openDraft(draftId) {
      if (typeof fetch !== 'function') return;
      if (!draftId) return;
      try {
        // Fetch list and filter (no GET /api/drafts/:draftId endpoint)
        const response = await fetch('/api/drafts', {
          credentials: 'same-origin',
        });
        if (!response.ok) return;
        const drafts = await response.json();
        const draft = drafts.find(d => d.draftId === draftId);
        if (!draft) return;
        currentDraft = draft;

        // Always select the prompt first so the slug header updates (test hook)
        if (draft.promptSlug) {
          selectPrompt(draft.promptSlug, { trackHistory: false });
        }

        if (draft.type === 'new') {
          // Extract tempId from draftId (format: "new:temp_...")
          const tempId = draft.draftId.replace(/^new:/, '');

          // Save current list state if first staging entry
          if (stagingPrompts.length === 0) {
            const listEl = document.getElementById('prompt-list');
            savedListState = {
              query: '',
              tags: [],
              scrollTop: listEl ? listEl.scrollTop : 0
            };
          }

          // Create staging entry with matching tempId (do NOT call enterInsertMode)
          stagingPrompts.push({
            tempId: tempId,
            data: draft.data
          });
          selectedStagingId = tempId;
          currentMode = 'new';

          renderStagingList();
          await showEditor(draft.data);
          isDirty = false;
          updateStagingFooter();
        } else {
          // Edit draft: show editor with draft data
          selectedSlug = draft.promptSlug || selectedSlug;
          currentMode = 'edit';
          await showEditor(draft.data);
        }

        checkDraftExpiration(draft);
      } catch (err) {
        console.error('Failed to open draft:', err);
      }
    }

    // Handle messages from shell
    window.addEventListener('message', (e) => {
      // Only accept messages from same origin (shell)
      if (e.origin !== window.location.origin) return;

      const { type, ...payload } = e.data || {};

      switch (type) {
        case 'shell:search':
          // Legacy: search only
          loadPrompts(payload.query);
          break;

        case 'shell:filter':
          // Search + tag filtering
          loadPrompts(payload.query || '', payload.tags || []);
          break;

        case 'shell:state':
          // Restore state from shell (back/forward navigation or initial load)
          restoreState(payload.state);
          break;

        case 'shell:drafts:open':
          // Request to open specific draft
          openDraft(payload.draftId);
          break;

        case 'shell:theme':
          // Theme change from shell - update portlet theme
          applyTheme(payload.theme);
          break;
      }
    });

    // Injected from server - source of truth: src/schemas/preferences.ts
    const VALID_THEMES = {{validThemes}};

    /**
     * Apply theme to portlet by updating CSS link.
     * Called when shell broadcasts theme change.
     */
    function applyTheme(themeId) {
      if (!VALID_THEMES.includes(themeId)) {
        console.error('Invalid theme:', themeId);
        return;
      }

      const themeStylesheet = document.getElementById('theme-stylesheet');
      if (themeStylesheet) {
        themeStylesheet.href = `/shared/themes/${themeId}.css`;
      }
    }

    // New prompt - enter insert mode
    document.getElementById('new-prompt-btn').addEventListener('click', () => {
      enterInsertMode();
    });

    // Edit button
    document.getElementById('edit-btn').addEventListener('click', () => {
      enterEditMode();
    });

    // Line edit toggle
    document.getElementById('line-edit-toggle').addEventListener('click', toggleLineEdit);

    // Staging footer buttons
    document.getElementById('save-all-btn').addEventListener('click', saveAll);
    document.getElementById('discard-all-btn').addEventListener('click', discardAll);

    // Copy button
    document.getElementById('copy-btn').addEventListener('click', copyContent);

    // Home module tab navigation
    document.querySelectorAll('.home-tab').forEach(btn => {
      btn.addEventListener('click', () => {
        switchHomeTab(btn.dataset.tab);
      });
    });

    // CTA button on landing page
    const ctaBtn = document.getElementById('cta-new-prompt');
    if (ctaBtn) {
      ctaBtn.addEventListener('click', () => {
        enterInsertMode();
      });
    }

    // Help tab internal link to getting-started
    document.querySelectorAll('.help-link[data-tab]').forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        switchHomeTab(link.dataset.tab);
      });
    });

    // Copy code buttons in integration guides
    document.querySelectorAll('.copy-code-btn').forEach(btn => {
      btn.addEventListener('click', async () => {
        const codeBlock = btn.closest('.code-block');
        if (!codeBlock) return;

        const codeEl = codeBlock.querySelector('code, pre');
        if (!codeEl) return;

        try {
          await navigator.clipboard.writeText(codeEl.textContent.trim());
          const originalText = btn.textContent;
          btn.textContent = '‚úì Copied!';
          btn.classList.add('copied');
          setTimeout(() => {
            btn.textContent = originalText;
            btn.classList.remove('copied');
          }, 1200);
        } catch (err) {
          console.error('Failed to copy:', err);
        }
      });
    });

    // Pin/favorite toggle handlers
    async function handlePinToggle(slug, currentPinned) {
      // Capture original state before any mutations (prevents race condition with concurrent toggles)
      const originalFlags = { ...currentPromptFlags };
      const newPinned = !currentPinned;

      // Optimistic UI update
      updatePinUI(slug, newPinned);
      currentPromptFlags.pinned = newPinned;

      try {
        // API call (cookie auth - no Authorization header needed)
        const res = await fetch(`/api/prompts/${slug}/flags`, {
          method: 'PATCH',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ pinned: newPinned })
        });

        if (!res.ok) throw new Error('Pin update failed');

        // Refresh list to get new order (preserving current filters)
        await loadPrompts(currentQuery, currentTags);
      } catch (err) {
        console.error('Pin toggle failed:', err);
        // Rollback using captured original state
        handleOptimisticRollback(slug, originalFlags);
        showToast('Failed to update pin status', { type: 'error' });
      }
    }

    async function handleFavoriteToggle(slug, currentFavorited) {
      // Capture original state before any mutations (prevents race condition with concurrent toggles)
      const originalFlags = { ...currentPromptFlags };
      const newFavorited = !currentFavorited;

      // Optimistic UI update
      updateFavoriteUI(slug, newFavorited);
      currentPromptFlags.favorited = newFavorited;

      try {
        // API call (cookie auth - no Authorization header needed)
        const res = await fetch(`/api/prompts/${slug}/flags`, {
          method: 'PATCH',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ favorited: newFavorited })
        });

        if (!res.ok) throw new Error('Favorite update failed');

        // Refresh list to get new order (preserving current filters)
        await loadPrompts(currentQuery, currentTags);
      } catch (err) {
        console.error('Favorite toggle failed:', err);
        // Rollback using captured original state
        handleOptimisticRollback(slug, originalFlags);
        showToast('Failed to update favorite status', { type: 'error' });
      }
    }

    function handleOptimisticRollback(slug, previousFlags) {
      updatePinUI(slug, previousFlags.pinned);
      updateFavoriteUI(slug, previousFlags.favorited);
      currentPromptFlags = previousFlags;
    }

    function updatePinUI(slug, pinned) {
      const pinButton = document.getElementById('pin-toggle');
      if (pinButton) {
        pinButton.classList.toggle('active', pinned);
        pinButton.setAttribute('aria-pressed', String(pinned));
        pinButton.title = pinned ? 'Unpin prompt' : 'Pin prompt';
      }

      // Update list item (use .prompt-pin class to match test hooks)
      const listItem = document.querySelector(`[data-slug="${slug}"] .prompt-pin`);
      if (listItem) {
        listItem.style.display = pinned ? '' : 'none';
      }
    }

    function updateFavoriteUI(slug, favorited) {
      const starButton = document.getElementById('favorite-toggle');
      if (starButton) {
        starButton.classList.toggle('active', favorited);
        starButton.setAttribute('aria-pressed', String(favorited));
        starButton.title = favorited ? 'Unfavorite prompt' : 'Favorite prompt';
      }

      // Update list item (use .prompt-star class to match test hooks)
      const listItem = document.querySelector(`[data-slug="${slug}"] .prompt-star`);
      if (listItem) {
        listItem.style.display = favorited ? '' : 'none';
      }
    }

    // Empty state rendering
    function renderEmptyState(type) {
      const list = document.getElementById('prompt-list');
      const emptyState = document.getElementById('empty-state');

      if (!list || !emptyState) return;

      list.innerHTML = '';
      emptyState.style.display = 'flex';

      if (type === 'no-prompts') {
        emptyState.innerHTML = `
          <div class="empty-state-content">
            <p>Create your first prompt to get started.</p>
            <button id="empty-state-new-btn" class="btn-primary">+ New Prompt</button>
          </div>
        `;
        // Wire up the button (using onclick to avoid listener accumulation)
        const newBtn = emptyState.querySelector('#empty-state-new-btn');
        if (newBtn) {
          newBtn.onclick = () => enterInsertMode();
        }
      } else if (type === 'no-matches') {
        emptyState.innerHTML = `
          <div class="empty-state-content">
            <p>No prompts match your search.</p>
          </div>
        `;
      }
    }

    // Pin toggle button
    document.getElementById('pin-toggle').addEventListener('click', () => {
      if (!selectedSlug) return;
      handlePinToggle(selectedSlug, currentPromptFlags.pinned);
    });

    // Favorite toggle button
    document.getElementById('favorite-toggle').addEventListener('click', () => {
      if (!selectedSlug) return;
      handleFavoriteToggle(selectedSlug, currentPromptFlags.favorited);
    });

    // Initialize view mode and line edit
    initViewMode();
    initLineEditMode();
    updateLineEditAvailability();

    // Initial load - deferred to allow test mocking
    // In production, call loadPrompts() after DOMContentLoaded
    // For TDD: tests will call window.loadPrompts() after setting up mocks
    window.loadPrompts = loadPrompts;
    window.selectPrompt = selectPrompt;
    window.clearSelection = clearSelection;
    window.restoreState = restoreState;
    window.enterInsertMode = enterInsertMode;
    window.enterEditMode = enterEditMode;
    window.enterHomeMode = enterHomeMode;
    window.switchHomeTab = switchHomeTab;

    async function init() {
      await loadPrompts();

      // If we already have a slug from restoreState (before prompts loaded),
      // select it now that prompts are available
      if (selectedSlug && prompts.length > 0) {
        const prompt = prompts.find(p => p.slug === selectedSlug);
        if (prompt) {
          selectPrompt(selectedSlug, { trackHistory: false });
        }
      } else if (currentMode === 'home') {
        // Start in home mode (default state)
        enterHomeMode({ trackHistory: false });
      }

      // Tell shell we're ready to receive state
      notifyShellReady();
    }

    if (!navigator.userAgent.includes("jsdom")) {
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    }
  </script>
</body>
</html>
