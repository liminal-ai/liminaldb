<!DOCTYPE html>
<html lang="en" data-surface="webapp">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LiminalDB</title>
  <link rel="stylesheet" href="/shared/themes/base.css">
  <link rel="stylesheet" href="/shared/themes/dark-1.css" id="theme-stylesheet">
</head>
<body class="shell">
  <script src="/js/utils.js"></script>
  <script src="/js/components/tag-selector.js"></script>
  <script src="/js/components/toast.js"></script>
  <div id="toast-container" class="toast-container"></div>
  <header class="shell-header">
    <div class="search-group">
      <input type="search" id="search-input" class="search-input" placeholder="Search prompts..." />
      <div class="tag-picker">
        <button class="tag-picker-btn" id="tag-picker-btn">Tags</button>
        <div class="tag-picker-dropdown" id="tag-picker-dropdown"></div>
      </div>
      <div class="filter-tags" id="filter-tags"></div>
    </div>
    <div class="logo"><strong>LIMINAL</strong>DB</div>
    <div class="theme-picker hidden" id="theme-picker">
      <button class="theme-picker-btn" id="theme-picker-btn" aria-haspopup="true" aria-expanded="false">Theme</button>
      <div class="theme-picker-dropdown" id="theme-picker-dropdown" role="menu">
        <div class="theme-picker-item" data-theme="light-1" role="menuitem">Light 1</div>
        <div class="theme-picker-item" data-theme="light-2" role="menuitem">Light 2</div>
        <div class="theme-picker-item" data-theme="light-3" role="menuitem">Light 3</div>
        <div class="theme-picker-item" data-theme="dark-1" role="menuitem">Dark 1</div>
        <div class="theme-picker-item" data-theme="dark-2" role="menuitem">Dark 2</div>
        <div class="theme-picker-item" data-theme="dark-3" role="menuitem">Dark 3</div>
      </div>
    </div>
    <div class="user-info">
      <span class="user-email">{{email}}</span>
      <a href="/auth/logout" class="sign-out-link">Sign out</a>
    </div>
  </header>

  <main class="shell-main">
    <iframe
      src="{{modulePath}}"
      class="module-frame"
      id="main-module"
    ></iframe>
  </main>

  <footer class="shell-footer">
    <span id="footer-status" class="shell-footer-status"></span>
    <button id="footer-new-btn" class="shell-footer-btn shell-footer-btn-accent">+ New</button>
    <button id="footer-transfer-btn" class="shell-footer-btn shell-footer-btn-ghost">Import / Export</button>
  </footer>

  <!-- Transfer Dialog (Import / Export) -->
  <div id="transfer-dialog" class="transfer-dialog" style="display: none;">
    <div class="transfer-dialog-content">
      <div class="transfer-dialog-header">
        <div class="transfer-tabs">
          <button class="transfer-tab active" data-tab="export">Export</button>
          <button class="transfer-tab" data-tab="import">Import</button>
        </div>
        <button class="transfer-close" aria-label="Close">&times;</button>
      </div>

      <!-- Export Tab -->
      <div id="transfer-tab-export" class="transfer-tab-panel active">
        <div class="transfer-toolbar">
          <label class="transfer-select-all">
            <input type="checkbox" id="export-select-all" checked> Select all
          </label>
          <input type="search" id="export-search" class="transfer-search" placeholder="Filter prompts...">
          <span id="export-count" class="transfer-count"></span>
        </div>
        <div id="export-list" class="transfer-list">
          <div class="transfer-loading">Loading prompts...</div>
        </div>
        <div class="transfer-actions">
          <button class="btn btn-secondary btn-sm" id="transfer-cancel-export">Cancel</button>
          <button class="btn btn-primary btn-sm" id="transfer-do-export">Export</button>
        </div>
      </div>

      <!-- Import Tab -->
      <div id="transfer-tab-import" class="transfer-tab-panel">
        <div id="import-drop-zone" class="import-drop-zone">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/>
          </svg>
          <span>Drop a YAML file or <button class="import-browse-link" id="import-browse-btn">browse</button></span>
          <input type="file" id="import-file-input" accept=".yaml,.yml" style="display: none;">
        </div>
        <div id="import-preview" style="display: none;">
          <div class="transfer-toolbar">
            <label class="transfer-select-all">
              <input type="checkbox" id="import-select-all" checked> Select all
            </label>
            <input type="search" id="import-search" class="transfer-search" placeholder="Filter prompts...">
            <span id="import-count" class="transfer-count"></span>
          </div>
          <div id="import-list" class="transfer-list"></div>
          <div class="transfer-actions">
            <button class="btn btn-secondary btn-sm" id="transfer-cancel-import">Cancel</button>
            <button class="btn btn-primary btn-sm" id="transfer-do-import">Import</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    window.__AUTH__ = {
      userId: "{{userId}}",
      email: "{{email}}"
    };

    // Elements
    const searchInput = document.getElementById('search-input');
    const moduleFrame = document.getElementById('main-module');
    const tagPickerBtn = document.getElementById('tag-picker-btn');
    const tagPickerDropdown = document.getElementById('tag-picker-dropdown');
    const filterTagsContainer = document.getElementById('filter-tags');

    // State
    let allTags = [];
    let selectedTags = [];
    let debounceTimer;
    let portletDirty = false;

    // ============================================
    // HISTORY / ROUTER
    // ============================================

    /**
     * Parse current URL path to extract portlet state.
     * Pattern: /prompts/:slug?/:mode?
     * Examples:
     *   /prompts           â†’ { portlet: 'prompts', slug: null, mode: 'empty' }
     *   /prompts/sql-query â†’ { portlet: 'prompts', slug: 'sql-query', mode: 'view' }
     *   /prompts/sql-query/edit â†’ { portlet: 'prompts', slug: 'sql-query', mode: 'edit' }
     *   /prompts/new       â†’ { portlet: 'prompts', slug: null, mode: 'new' }
     */
    function parseUrlState() {
      const path = window.location.pathname;
      const parts = path.split('/').filter(Boolean);

      // Default state
      const state = {
        portlet: 'prompts',
        slug: null,
        mode: 'empty'
      };

      if (parts[0] === 'prompts') {
        if (parts[1] === 'new') {
          state.mode = 'new';
        } else if (parts[1]) {
          state.slug = parts[1];
          state.mode = parts[2] === 'edit' ? 'edit' : 'view';
        }
      }

      return state;
    }

    /**
     * Build URL path from state object.
     */
    function buildUrlPath(state) {
      if (state.mode === 'new') {
        return '/prompts/new';
      }
      if (state.slug) {
        return state.mode === 'edit'
          ? `/prompts/${state.slug}/edit`
          : `/prompts/${state.slug}`;
      }
      return '/prompts';
    }

    /**
     * Push state to browser history and update URL.
     */
    function pushHistoryState(state, trackHistory = true) {
      const url = buildUrlPath(state);

      if (trackHistory) {
        history.pushState(state, '', url);
      } else {
        history.replaceState(state, '', url);
      }
    }

    /**
     * Send state to portlet for restoration.
     */
    function sendStateToPortlet(state) {
      if (moduleFrame.contentWindow) {
        moduleFrame.contentWindow.postMessage({
          type: 'shell:state',
          state: state
        }, window.location.origin);
      }
    }

    /**
     * Handle browser back/forward navigation.
     * If portlet has unsaved changes, confirm before navigating.
     */
    window.addEventListener('popstate', async (e) => {
      if (portletDirty) {
        // Confirm navigation with unsaved changes
        const confirmed = window.confirm('You have unsaved changes. Discard and navigate away?');
        if (!confirmed) {
          // Push current state back to history to cancel the navigation
          history.pushState(history.state, '', window.location.pathname);
          return;
        }
        portletDirty = false;
      }
      const state = e.state || parseUrlState();
      sendStateToPortlet(state);
    });

    /**
     * Initialize history state on page load.
     * Replace current history entry with parsed state.
     */
    function initHistoryState() {
      const state = parseUrlState();
      history.replaceState(state, '', window.location.pathname);
      return state;
    }

    // Fetch all unique tags from API
    async function loadTags() {
      try {
        const response = await fetch('/api/prompts/tags');
        if (response.ok) {
          allTags = await response.json();
          renderTagPicker();
        }
      } catch (err) {
        console.error('Failed to load tags:', err);
      }
    }

    // Render tag picker dropdown (grouped by dimension)
    function renderTagPicker() {
      tagPickerDropdown.innerHTML = tagSelector.renderHtml(allTags, selectedTags, { style: 'list' });
      tagSelector.attachHandlers(tagPickerDropdown, (tag) => toggleTag(tag), { style: 'list' });
    }

    // Toggle tag selection
    function toggleTag(tag) {
      const index = selectedTags.indexOf(tag);
      if (index === -1) {
        selectedTags.push(tag);
      } else {
        selectedTags.splice(index, 1);
      }
      renderTagPicker();
      renderFilterPills();
      broadcastFilters();
    }

    // Remove tag from selection
    function removeTag(tag) {
      const index = selectedTags.indexOf(tag);
      if (index !== -1) {
        selectedTags.splice(index, 1);
        renderTagPicker();
        renderFilterPills();
        broadcastFilters();
      }
    }

    // Render filter pills in header
    function renderFilterPills() {
      filterTagsContainer.innerHTML = selectedTags.map(tag => `
        <span class="filter-pill">
          ${escapeHtml(tag)}
          <button class="remove" data-tag="${escapeHtml(tag)}" title="Remove filter">Ã—</button>
        </span>
      `).join('');

      // Add remove handlers
      filterTagsContainer.querySelectorAll('.remove').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          removeTag(btn.dataset.tag);
        });
      });
    }

    // Broadcast search and tag filters to module
    function broadcastFilters() {
      if (!moduleFrame.contentWindow) return;
      moduleFrame.contentWindow.postMessage({
        type: 'shell:filter',
        query: searchInput.value,
        tags: selectedTags
      }, window.location.origin);
    }

    // Toggle dropdown visibility
    function toggleDropdown() {
      tagPickerDropdown.classList.toggle('open');
    }

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.tag-picker')) {
        tagPickerDropdown.classList.remove('open');
      }
    });

    // Tag picker button click
    tagPickerBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleDropdown();
    });

    // Search input with debounce
    searchInput.addEventListener('input', (e) => {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => {
        broadcastFilters();
      }, 150);
    });

    // Cmd+K focuses search
    document.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault();
        searchInput.focus();
      }
    });

    // Handle messages from portlets
    window.addEventListener('message', (e) => {
      if (e.origin !== window.location.origin) return;

      const { type, ...payload } = e.data || {};

      switch (type) {
        case 'module:navigate':
          // Full page navigation (portlet change)
          const path = payload.path;
          if (typeof path === 'string' && path.startsWith('/') && !path.startsWith('//')) {
            window.location.href = path;
          }
          break;

        case 'history:push':
          // Portlet state change - update browser history
          if (payload.state) {
            const trackHistory = payload.trackHistory !== false;
            pushHistoryState(payload.state, trackHistory);
          }
          break;

        case 'portlet:ready':
          // Portlet loaded and ready - send initial state and current theme
          const initialState = parseUrlState();
          sendStateToPortlet(initialState);
          broadcastThemeToPortlet(currentTheme);
          break;

        case 'portlet:dirty':
          // Track dirty state from portlet
          portletDirty = payload.dirty === true;
          break;

        case 'portlet:prompt-count':
          // Prompt count update from portlet
          updateFooterStatus(payload.count);
          break;

        case 'portlet:prompt-list':
          // Full prompt list for export dialog
          renderExportList(payload.prompts || []);
          break;
      }
    });

    // ============================================
    // DRAFT INDICATOR
    // ============================================

    // ============================================
    // THEME PICKER
    // ============================================

    const themePicker = document.getElementById('theme-picker');
    const themePickerBtn = document.getElementById('theme-picker-btn');
    const themePickerDropdown = document.getElementById('theme-picker-dropdown');
    const themeStylesheet = document.getElementById('theme-stylesheet');
    let currentTheme = 'dark-1'; // Default theme

    // Injected from server - source of truth: src/schemas/preferences.ts
    const VALID_THEMES = {{validThemes}};
    const VALID_SURFACES = {{validSurfaces}};

    /**
     * Get the current surface from the data-surface attribute.
     * Defaults to 'webapp' if not set or invalid.
     */
    function getCurrentSurface() {
      const surface = document.documentElement.dataset.surface;
      return VALID_SURFACES.includes(surface) ? surface : 'webapp';
    }

    /**
     * Toggle theme dropdown visibility
     */
    function toggleThemeDropdown() {
      const isOpen = themePickerDropdown.classList.toggle('open');
      themePickerBtn.setAttribute('aria-expanded', String(isOpen));
    }

    /**
     * Close theme dropdown
     */
    function closeThemeDropdown() {
      themePickerDropdown.classList.remove('open');
      themePickerBtn.setAttribute('aria-expanded', 'false');
    }

    /**
     * Update theme selection UI (checkmark on selected theme)
     */
    function updateThemeSelectionUI(themeId) {
      themePickerDropdown.querySelectorAll('.theme-picker-item').forEach(item => {
        item.classList.toggle('selected', item.dataset.theme === themeId);
      });
    }

    /**
     * Set the theme - updates CSS link and persists via API
     */
    async function setTheme(themeId) {
      if (!VALID_THEMES.includes(themeId)) {
        console.error('Invalid theme:', themeId);
        return;
      }

      // Update CSS link immediately for responsive feel
      if (themeStylesheet) {
        themeStylesheet.href = `/shared/themes/${themeId}.css`;
      }
      currentTheme = themeId;
      updateThemeSelectionUI(themeId);

      // Broadcast to portlet
      broadcastThemeToPortlet(themeId);

      // Persist to server
      const surface = getCurrentSurface();
      try {
        const response = await fetch('/api/preferences', {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          credentials: 'include',
          body: JSON.stringify({ surface, theme: themeId }),
        });
        if (!response.ok) {
          console.error('Failed to save theme preference');
        }
      } catch (err) {
        console.error('Failed to save theme preference:', err);
      }
    }

    /**
     * Load theme preference from API.
     * Shows theme picker only if user is authenticated.
     * Returns true if authenticated and theme loaded, false otherwise.
     */
    async function loadThemePreference() {
      const surface = getCurrentSurface();
      try {
        const response = await fetch(`/api/preferences?surface=${surface}`, {
          credentials: 'include',
        });
        if (response.ok) {
          const data = await response.json();
          if (data.theme && VALID_THEMES.includes(data.theme)) {
            currentTheme = data.theme;
            if (themeStylesheet) {
              themeStylesheet.href = `/shared/themes/${data.theme}.css`;
            }
            updateThemeSelectionUI(data.theme);
            broadcastThemeToPortlet(data.theme);
          }
          // User is authenticated - show theme picker
          if (themePicker) {
            themePicker.classList.remove('hidden');
          }
          return true;
        }
        // 401 or other error - user not authenticated, keep picker hidden
        return false;
      } catch (err) {
        console.error('Failed to load theme preference:', err);
        return false;
      }
    }

    /**
     * Broadcast theme change to portlet iframe
     */
    function broadcastThemeToPortlet(themeId) {
      if (moduleFrame && moduleFrame.contentWindow) {
        moduleFrame.contentWindow.postMessage({
          type: 'shell:theme',
          theme: themeId
        }, window.location.origin);
      }
    }

    // Theme picker button click
    if (themePickerBtn) {
      themePickerBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleThemeDropdown();
      });
    }

    // Theme item click handlers
    if (themePickerDropdown) {
      themePickerDropdown.querySelectorAll('.theme-picker-item').forEach(item => {
        item.addEventListener('click', async () => {
          const themeId = item.dataset.theme;
          if (VALID_THEMES.includes(themeId)) {
            closeThemeDropdown();
            try {
              await setTheme(themeId);
            } catch (err) {
              console.error('Theme switch failed:', err);
            }
          }
        });
      });
    }

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.theme-picker')) {
        closeThemeDropdown();
      }
    });

    // ============================================
    // SHELL FOOTER
    // ============================================

    const footerNewBtn = document.getElementById('footer-new-btn');
    const footerTransferBtn = document.getElementById('footer-transfer-btn');
    const footerStatus = document.getElementById('footer-status');

    // "+ New" sends action to portlet
    if (footerNewBtn) {
      footerNewBtn.addEventListener('click', () => {
        if (moduleFrame && moduleFrame.contentWindow) {
          moduleFrame.contentWindow.postMessage({
            type: 'shell:action',
            action: 'new-prompt'
          }, window.location.origin);
        }
      });
    }

    // Update footer status with prompt count
    function updateFooterStatus(count) {
      if (footerStatus) {
        footerStatus.textContent = count != null
          ? `${count} prompt${count !== 1 ? 's' : ''}`
          : '';
      }
    }

    // ============================================
    // TRANSFER DIALOG (IMPORT / EXPORT)
    // ============================================

    const transferDialog = document.getElementById('transfer-dialog');
    const transferTabs = transferDialog?.querySelectorAll('.transfer-tab');
    const transferPanels = transferDialog?.querySelectorAll('.transfer-tab-panel');
    const transferClose = transferDialog?.querySelector('.transfer-close');

    let cachedPromptList = []; // Cached from portlet for export

    function openTransferDialog(tab = 'export') {
      if (!transferDialog) return;
      transferDialog.style.display = 'flex';
      switchTransferTab(tab);

      if (tab === 'export') {
        // Request prompt list from portlet
        if (moduleFrame && moduleFrame.contentWindow) {
          moduleFrame.contentWindow.postMessage({
            type: 'shell:action',
            action: 'get-prompt-list'
          }, window.location.origin);
        }
      }
    }

    function closeTransferDialog() {
      if (!transferDialog) return;
      transferDialog.style.display = 'none';
      // Reset import state
      const dropZone = document.getElementById('import-drop-zone');
      const preview = document.getElementById('import-preview');
      if (dropZone) dropZone.style.display = '';
      if (preview) preview.style.display = 'none';
      const fileInput = document.getElementById('import-file-input');
      if (fileInput) fileInput.value = '';
      // Clear search filters and pending state
      const exportSearch = document.getElementById('export-search');
      const importSearch = document.getElementById('import-search');
      if (exportSearch) exportSearch.value = '';
      if (importSearch) importSearch.value = '';
      pendingImportYaml = '';
    }

    function switchTransferTab(tabName) {
      transferTabs?.forEach(t => t.classList.toggle('active', t.dataset.tab === tabName));
      transferPanels?.forEach(p => {
        p.classList.toggle('active', p.id === `transfer-tab-${tabName}`);
      });
    }

    // Tab clicks
    transferTabs?.forEach(tab => {
      tab.addEventListener('click', () => switchTransferTab(tab.dataset.tab));
    });

    // Close button + click outside + Escape
    transferClose?.addEventListener('click', closeTransferDialog);
    transferDialog?.addEventListener('click', (e) => {
      if (e.target === transferDialog) closeTransferDialog();
    });
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && transferDialog?.style.display === 'flex') {
        closeTransferDialog();
      }
    });

    // Open dialog from footer button
    if (footerTransferBtn) {
      footerTransferBtn.addEventListener('click', () => openTransferDialog('export'));
    }

    // Cancel buttons
    document.getElementById('transfer-cancel-export')?.addEventListener('click', closeTransferDialog);
    document.getElementById('transfer-cancel-import')?.addEventListener('click', closeTransferDialog);

    // --- Export ---

    function renderExportList(prompts) {
      cachedPromptList = prompts || [];
      const list = document.getElementById('export-list');
      const selectAll = document.getElementById('export-select-all');
      if (!list) return;

      list.innerHTML = prompts.map(p => `
        <label class="transfer-item" data-slug="${escapeHtml(p.slug)}">
          <input type="checkbox" checked>
          <div class="transfer-item-info">
            <span class="transfer-item-name">${escapeHtml(p.name)}</span>
            <span class="transfer-item-slug">${escapeHtml(p.slug)}</span>
          </div>
          ${p.pinned ? '<span class="transfer-item-pin">ðŸ“Œ</span>' : ''}
        </label>
      `).join('');

      if (selectAll) selectAll.checked = true;
      updateExportCount();

      // Checkbox changes update count
      list.querySelectorAll('input[type="checkbox"]').forEach(cb => {
        cb.addEventListener('change', updateExportCount);
      });
    }

    function updateExportCount() {
      const checked = document.querySelectorAll('#export-list input[type="checkbox"]:checked').length;
      const total = document.querySelectorAll('#export-list input[type="checkbox"]').length;
      const countEl = document.getElementById('export-count');
      const btn = document.getElementById('transfer-do-export');
      if (countEl) countEl.textContent = `${checked} of ${total} selected`;
      if (btn) {
        btn.textContent = `Export ${checked} prompt${checked !== 1 ? 's' : ''}`;
        btn.disabled = checked === 0;
      }
    }

    // Filter within export list
    document.getElementById('export-search')?.addEventListener('input', (e) => {
      const q = e.target.value.toLowerCase();
      document.querySelectorAll('#export-list .transfer-item').forEach(item => {
        const name = item.querySelector('.transfer-item-name')?.textContent?.toLowerCase() || '';
        const slug = item.dataset.slug?.toLowerCase() || '';
        item.style.display = (name.includes(q) || slug.includes(q)) ? '' : 'none';
      });
    });

    // Select all toggle for export
    document.getElementById('export-select-all')?.addEventListener('change', (e) => {
      document.querySelectorAll('#export-list input[type="checkbox"]').forEach(cb => {
        cb.checked = e.target.checked;
      });
      updateExportCount();
    });

    // Do export
    document.getElementById('transfer-do-export')?.addEventListener('click', async () => {
      const checkedSlugs = [];
      document.querySelectorAll('#export-list .transfer-item').forEach(item => {
        if (item.querySelector('input[type="checkbox"]')?.checked) {
          checkedSlugs.push(item.dataset.slug);
        }
      });
      if (checkedSlugs.length === 0) return;

      try {
        const total = document.querySelectorAll('#export-list .transfer-item').length;
        const isAll = checkedSlugs.length === total;
        let exportUrl = '/api/prompts/export';
        if (!isAll) {
          const params = new URLSearchParams();
          checkedSlugs.forEach(s => params.append('slugs', s));
          exportUrl += `?${params}`;
        }
        const response = await fetch(exportUrl, { credentials: 'include' });
        if (!response.ok) {
          const errData = await response.json().catch(() => ({}));
          throw new Error(errData.error || `Export failed (${response.status})`);
        }

        const blob = await response.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = response.headers.get('content-disposition')
          ?.match(/filename="(.+)"/)?.[1] || 'liminaldb-prompts.yaml';
        a.click();
        URL.revokeObjectURL(url);
        showToast(`Exported ${checkedSlugs.length} prompt${checkedSlugs.length !== 1 ? 's' : ''}`, { type: 'success' });
        closeTransferDialog();
      } catch (err) {
        showToast(err.message || 'Failed to export prompts', { type: 'error' });
      }
    });

    // --- Import ---

    const importDropZone = document.getElementById('import-drop-zone');
    const importFileInput = document.getElementById('import-file-input');
    const importBrowseBtn = document.getElementById('import-browse-btn');

    importBrowseBtn?.addEventListener('click', (e) => {
      e.preventDefault();
      importFileInput?.click();
    });

    // Drag and drop
    importDropZone?.addEventListener('dragover', (e) => {
      e.preventDefault();
      importDropZone.classList.add('drag-over');
    });
    importDropZone?.addEventListener('dragleave', () => {
      importDropZone.classList.remove('drag-over');
    });
    importDropZone?.addEventListener('drop', (e) => {
      e.preventDefault();
      importDropZone.classList.remove('drag-over');
      const file = e.dataTransfer?.files[0];
      if (file && (file.name.endsWith('.yaml') || file.name.endsWith('.yml'))) {
        previewImportFile(file);
      }
    });

    importFileInput?.addEventListener('change', (e) => {
      const file = e.target.files?.[0];
      if (file) previewImportFile(file);
    });

    async function previewImportFile(file) {
      try {
        const yamlContent = await file.text();
        const response = await fetch('/api/prompts/import/preview', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ yaml: yamlContent }),
        });
        const result = await response.json();
        if (!response.ok) {
          showToast(result.error || 'Failed to parse file', { type: 'error' });
          return;
        }
        renderImportPreview(result, yamlContent);
      } catch (err) {
        showToast('Failed to parse file', { type: 'error' });
      }
    }

    let pendingImportYaml = '';

    function renderImportPreview(result, yamlContent) {
      pendingImportYaml = yamlContent;
      const dropZone = document.getElementById('import-drop-zone');
      const preview = document.getElementById('import-preview');
      const list = document.getElementById('import-list');
      const selectAll = document.getElementById('import-select-all');
      if (!preview || !list) return;

      if (dropZone) dropZone.style.display = 'none';
      preview.style.display = '';

      const prompts = result.prompts || [];
      list.innerHTML = prompts.map(p => {
        const isDuplicate = p.duplicate === true;
        return `
          <label class="transfer-item ${isDuplicate ? 'transfer-item-duplicate' : ''}" data-slug="${escapeHtml(p.slug)}">
            <input type="checkbox" ${isDuplicate ? '' : 'checked'} ${isDuplicate ? 'disabled' : ''}>
            <div class="transfer-item-info">
              <span class="transfer-item-name">${escapeHtml(p.name)}</span>
              <span class="transfer-item-slug">${escapeHtml(p.slug)}${isDuplicate ? ' (already exists)' : ''}</span>
            </div>
          </label>
        `;
      }).join('');

      if (result.errors && result.errors.length > 0) {
        list.innerHTML += result.errors.map(err => `
          <div class="transfer-item transfer-item-error">
            <span class="transfer-item-slug">${escapeHtml(err)}</span>
          </div>
        `).join('');
      }

      if (selectAll) selectAll.checked = true;
      updateImportCount();

      list.querySelectorAll('input[type="checkbox"]:not(:disabled)').forEach(cb => {
        cb.addEventListener('change', updateImportCount);
      });
    }

    function updateImportCount() {
      const checked = document.querySelectorAll('#import-list input[type="checkbox"]:checked:not(:disabled)').length;
      const total = document.querySelectorAll('#import-list input[type="checkbox"]:not(:disabled)').length;
      const countEl = document.getElementById('import-count');
      const btn = document.getElementById('transfer-do-import');
      if (countEl) countEl.textContent = `${checked} of ${total} selected`;
      if (btn) {
        btn.textContent = `Import ${checked} prompt${checked !== 1 ? 's' : ''}`;
        btn.disabled = checked === 0;
      }
    }

    // Filter within import list
    document.getElementById('import-search')?.addEventListener('input', (e) => {
      const q = e.target.value.toLowerCase();
      document.querySelectorAll('#import-list .transfer-item').forEach(item => {
        const name = item.querySelector('.transfer-item-name')?.textContent?.toLowerCase() || '';
        const slug = item.dataset.slug?.toLowerCase() || '';
        item.style.display = (name.includes(q) || slug.includes(q)) ? '' : 'none';
      });
    });

    // Select all toggle for import
    document.getElementById('import-select-all')?.addEventListener('change', (e) => {
      document.querySelectorAll('#import-list input[type="checkbox"]:not(:disabled)').forEach(cb => {
        cb.checked = e.target.checked;
      });
      updateImportCount();
    });

    // Do import
    document.getElementById('transfer-do-import')?.addEventListener('click', async () => {
      const selectedSlugs = [];
      document.querySelectorAll('#import-list .transfer-item:not(.transfer-item-duplicate)').forEach(item => {
        if (item.querySelector('input[type="checkbox"]')?.checked) {
          selectedSlugs.push(item.dataset.slug);
        }
      });
      if (selectedSlugs.length === 0) return;

      try {
        const response = await fetch('/api/prompts/import', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ yaml: pendingImportYaml, slugs: selectedSlugs }),
        });
        const result = await response.json();
        if (!response.ok) {
          showToast(result.error || 'Import failed', { type: 'error' });
          return;
        }

        let msg = `Imported ${result.created} prompt${result.created !== 1 ? 's' : ''}`;
        if (result.skipped?.length > 0) {
          msg += `, ${result.skipped.length} skipped`;
        }
        showToast(msg, { type: 'success' });

        // Tell portlet to refresh
        if (moduleFrame && moduleFrame.contentWindow) {
          moduleFrame.contentWindow.postMessage({
            type: 'shell:action',
            action: 'refresh-prompts'
          }, window.location.origin);
        }
        closeTransferDialog();
      } catch (err) {
        showToast('Failed to import prompts', { type: 'error' });
      }
    });

    // Initialize
    (async function init() {
      initHistoryState();
      loadTags();
      await loadThemePreference();
      updateThemeSelectionUI(currentTheme);
    })();
  </script>
</body>
</html>
