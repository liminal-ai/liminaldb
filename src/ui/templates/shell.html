<!DOCTYPE html>
<html lang="en" data-surface="webapp">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LiminalDB</title>
  <link rel="stylesheet" href="/shared/themes/base.css">
  <link rel="stylesheet" href="/shared/themes/dark-1.css" id="theme-stylesheet">
</head>
<body class="shell">
  <script src="/js/utils.js"></script>
  <script src="/js/components/tag-selector.js"></script>
  <header class="shell-header">
    <div class="search-group">
      <input type="search" id="search-input" class="search-input" placeholder="Search prompts..." />
      <div class="tag-picker">
        <button class="tag-picker-btn" id="tag-picker-btn">Tags</button>
        <div class="tag-picker-dropdown" id="tag-picker-dropdown"></div>
      </div>
      <div class="filter-tags" id="filter-tags"></div>
    </div>
    <div class="logo"><strong>LIMINAL</strong>DB</div>
    <div id="draft-indicator" class="draft-indicator hidden">
      <span class="draft-icon"></span>
      <span id="draft-count">0</span> unsaved
    </div>
    <div class="theme-picker hidden" id="theme-picker">
      <button class="theme-picker-btn" id="theme-picker-btn" aria-haspopup="true" aria-expanded="false">Theme</button>
      <div class="theme-picker-dropdown" id="theme-picker-dropdown" role="menu">
        <div class="theme-picker-item" data-theme="light-1" role="menuitem">Light 1</div>
        <div class="theme-picker-item" data-theme="light-2" role="menuitem">Light 2</div>
        <div class="theme-picker-item" data-theme="light-3" role="menuitem">Light 3</div>
        <div class="theme-picker-item" data-theme="dark-1" role="menuitem">Dark 1</div>
        <div class="theme-picker-item" data-theme="dark-2" role="menuitem">Dark 2</div>
        <div class="theme-picker-item" data-theme="dark-3" role="menuitem">Dark 3</div>
      </div>
    </div>
    <div class="user-info">{{email}}</div>
  </header>

  <main class="shell-main">
    <iframe
      src="{{modulePath}}"
      class="module-frame"
      id="main-module"
    ></iframe>
  </main>

  <script>
    window.__AUTH__ = {
      userId: "{{userId}}",
      email: "{{email}}"
    };

    // Elements
    const searchInput = document.getElementById('search-input');
    const moduleFrame = document.getElementById('main-module');
    const tagPickerBtn = document.getElementById('tag-picker-btn');
    const tagPickerDropdown = document.getElementById('tag-picker-dropdown');
    const filterTagsContainer = document.getElementById('filter-tags');

    // State
    let allTags = [];
    let selectedTags = [];
    let debounceTimer;
    let portletDirty = false;
    let draftPollingInterval = null;
    let currentDraftSummary = { count: 0, latestDraftId: null, hasExpiringSoon: false };

    // ============================================
    // HISTORY / ROUTER
    // ============================================

    /**
     * Parse current URL path to extract portlet state.
     * Pattern: /prompts/:slug?/:mode?
     * Examples:
     *   /prompts           → { portlet: 'prompts', slug: null, mode: 'empty' }
     *   /prompts/sql-query → { portlet: 'prompts', slug: 'sql-query', mode: 'view' }
     *   /prompts/sql-query/edit → { portlet: 'prompts', slug: 'sql-query', mode: 'edit' }
     *   /prompts/new       → { portlet: 'prompts', slug: null, mode: 'new' }
     */
    function parseUrlState() {
      const path = window.location.pathname;
      const parts = path.split('/').filter(Boolean);

      // Default state
      const state = {
        portlet: 'prompts',
        slug: null,
        mode: 'empty'
      };

      if (parts[0] === 'prompts') {
        if (parts[1] === 'new') {
          state.mode = 'new';
        } else if (parts[1]) {
          state.slug = parts[1];
          state.mode = parts[2] === 'edit' ? 'edit' : 'view';
        }
      }

      return state;
    }

    /**
     * Build URL path from state object.
     */
    function buildUrlPath(state) {
      if (state.mode === 'new') {
        return '/prompts/new';
      }
      if (state.slug) {
        return state.mode === 'edit'
          ? `/prompts/${state.slug}/edit`
          : `/prompts/${state.slug}`;
      }
      return '/prompts';
    }

    /**
     * Push state to browser history and update URL.
     */
    function pushHistoryState(state, trackHistory = true) {
      const url = buildUrlPath(state);

      if (trackHistory) {
        history.pushState(state, '', url);
      } else {
        history.replaceState(state, '', url);
      }
    }

    /**
     * Send state to portlet for restoration.
     */
    function sendStateToPortlet(state) {
      if (moduleFrame.contentWindow) {
        moduleFrame.contentWindow.postMessage({
          type: 'shell:state',
          state: state
        }, window.location.origin);
      }
    }

    /**
     * Handle browser back/forward navigation.
     * If portlet has unsaved changes, confirm before navigating.
     */
    window.addEventListener('popstate', async (e) => {
      if (portletDirty) {
        // Confirm navigation with unsaved changes
        const confirmed = window.confirm('You have unsaved changes. Discard and navigate away?');
        if (!confirmed) {
          // Push current state back to history to cancel the navigation
          history.pushState(history.state, '', window.location.pathname);
          return;
        }
        portletDirty = false;
      }
      const state = e.state || parseUrlState();
      sendStateToPortlet(state);
    });

    /**
     * Initialize history state on page load.
     * Replace current history entry with parsed state.
     */
    function initHistoryState() {
      const state = parseUrlState();
      history.replaceState(state, '', window.location.pathname);
      return state;
    }

    // Fetch all unique tags from API
    async function loadTags() {
      try {
        const response = await fetch('/api/prompts/tags');
        if (response.ok) {
          allTags = await response.json();
          renderTagPicker();
        }
      } catch (err) {
        console.error('Failed to load tags:', err);
      }
    }

    // Render tag picker dropdown (grouped by dimension)
    function renderTagPicker() {
      tagPickerDropdown.innerHTML = tagSelector.render(allTags, selectedTags, { style: 'list' });
      tagSelector.attachHandlers(tagPickerDropdown, (tag) => toggleTag(tag), { style: 'list' });
    }

    // Toggle tag selection
    function toggleTag(tag) {
      const index = selectedTags.indexOf(tag);
      if (index === -1) {
        selectedTags.push(tag);
      } else {
        selectedTags.splice(index, 1);
      }
      renderTagPicker();
      renderFilterPills();
      broadcastFilters();
    }

    // Remove tag from selection
    function removeTag(tag) {
      const index = selectedTags.indexOf(tag);
      if (index !== -1) {
        selectedTags.splice(index, 1);
        renderTagPicker();
        renderFilterPills();
        broadcastFilters();
      }
    }

    // Render filter pills in header
    function renderFilterPills() {
      filterTagsContainer.innerHTML = selectedTags.map(tag => `
        <span class="filter-pill">
          ${escapeHtml(tag)}
          <button class="remove" data-tag="${escapeHtml(tag)}" title="Remove filter">×</button>
        </span>
      `).join('');

      // Add remove handlers
      filterTagsContainer.querySelectorAll('.remove').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          removeTag(btn.dataset.tag);
        });
      });
    }

    // Broadcast search and tag filters to module
    function broadcastFilters() {
      if (!moduleFrame.contentWindow) return;
      moduleFrame.contentWindow.postMessage({
        type: 'shell:filter',
        query: searchInput.value,
        tags: selectedTags
      }, window.location.origin);
    }

    // Toggle dropdown visibility
    function toggleDropdown() {
      tagPickerDropdown.classList.toggle('open');
    }

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.tag-picker')) {
        tagPickerDropdown.classList.remove('open');
      }
    });

    // Tag picker button click
    tagPickerBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleDropdown();
    });

    // Search input with debounce
    searchInput.addEventListener('input', (e) => {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => {
        broadcastFilters();
      }, 150);
    });

    // Cmd+K focuses search
    document.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault();
        searchInput.focus();
      }
    });

    // Handle messages from portlets
    window.addEventListener('message', (e) => {
      if (e.origin !== window.location.origin) return;

      const { type, ...payload } = e.data || {};

      switch (type) {
        case 'module:navigate':
          // Full page navigation (portlet change)
          const path = payload.path;
          if (typeof path === 'string' && path.startsWith('/') && !path.startsWith('//')) {
            window.location.href = path;
          }
          break;

        case 'history:push':
          // Portlet state change - update browser history
          if (payload.state) {
            const trackHistory = payload.trackHistory !== false;
            pushHistoryState(payload.state, trackHistory);
          }
          break;

        case 'portlet:ready':
          // Portlet loaded and ready - send initial state
          const initialState = parseUrlState();
          sendStateToPortlet(initialState);
          break;

        case 'portlet:dirty':
          // Track dirty state from portlet
          portletDirty = payload.dirty === true;
          break;

        case 'portlet:drafts':
          // Draft updates from portlet
          updateDraftIndicator(payload);
          break;
      }
    });

    // ============================================
    // DRAFT INDICATOR
    // ============================================

    /**
     * Start polling for drafts
     */
    function startDraftPolling() {
      // Initial fetch
      fetchDraftSummary();

      // Poll every 15 seconds
      draftPollingInterval = setInterval(fetchDraftSummary, 15000);
    }

    async function fetchDraftSummary() {
      try {
        const response = await window.fetch('/api/drafts/summary', {
          credentials: 'same-origin'
        });
        if (!response.ok) return;
        const summary = await response.json();
        updateDraftIndicator(summary);
      } catch (e) {
        console.error('Draft polling failed:', e);
      }
    }

    /**
     * Update draft indicator UI
     * 
     * Shows/hides indicator based on draft count.
     * Updates count display and handles expiring soon state.
     */
    function updateDraftIndicator(summary) {
      if (!summary || typeof summary.count !== 'number') return;
      currentDraftSummary = {
        count: summary.count ?? 0,
        latestDraftId: summary.latestDraftId ?? null,
        hasExpiringSoon: summary.hasExpiringSoon === true,
      };

      const indicator = document.getElementById('draft-indicator');
      const countEl = document.getElementById('draft-count');
      if (!indicator || !countEl) return;

      if (currentDraftSummary.count > 0) {
        indicator.classList.remove('hidden');
        countEl.textContent = String(currentDraftSummary.count);
        indicator.classList.toggle('expiring-soon', currentDraftSummary.hasExpiringSoon);
      } else {
        indicator.classList.add('hidden');
        countEl.textContent = '0';
        indicator.classList.remove('expiring-soon');
      }
    }

    /**
     * Handle click on draft indicator
     * 
     * Navigates to the latest draft or opens draft management UI.
     */
    const draftIndicator = document.getElementById('draft-indicator');
    if (draftIndicator) {
      draftIndicator.addEventListener('click', () => {
        const draftId = currentDraftSummary?.latestDraftId;
        if (!draftId) return;
        if (moduleFrame && moduleFrame.contentWindow) {
          moduleFrame.contentWindow.postMessage({
            type: 'shell:drafts:open',
            draftId
          }, window.location.origin);
        }
      });
    }

    // ============================================
    // THEME PICKER
    // ============================================

    const themePicker = document.getElementById('theme-picker');
    const themePickerBtn = document.getElementById('theme-picker-btn');
    const themePickerDropdown = document.getElementById('theme-picker-dropdown');
    const themeStylesheet = document.getElementById('theme-stylesheet');
    let currentTheme = 'dark-1'; // Default theme

    // Injected from server - source of truth: src/schemas/preferences.ts
    const VALID_THEMES = {{validThemes}};
    const VALID_SURFACES = {{validSurfaces}};

    /**
     * Get the current surface from the data-surface attribute.
     * Defaults to 'webapp' if not set or invalid.
     */
    function getCurrentSurface() {
      const surface = document.documentElement.dataset.surface;
      return VALID_SURFACES.includes(surface) ? surface : 'webapp';
    }

    /**
     * Toggle theme dropdown visibility
     */
    function toggleThemeDropdown() {
      const isOpen = themePickerDropdown.classList.toggle('open');
      themePickerBtn.setAttribute('aria-expanded', String(isOpen));
    }

    /**
     * Close theme dropdown
     */
    function closeThemeDropdown() {
      themePickerDropdown.classList.remove('open');
      themePickerBtn.setAttribute('aria-expanded', 'false');
    }

    /**
     * Update theme selection UI (checkmark on selected theme)
     */
    function updateThemeSelectionUI(themeId) {
      themePickerDropdown.querySelectorAll('.theme-picker-item').forEach(item => {
        item.classList.toggle('selected', item.dataset.theme === themeId);
      });
    }

    /**
     * Set the theme - updates CSS link and persists via API
     */
    async function setTheme(themeId) {
      if (!VALID_THEMES.includes(themeId)) {
        console.error('Invalid theme:', themeId);
        return;
      }

      // Update CSS link immediately for responsive feel
      if (themeStylesheet) {
        themeStylesheet.href = `/shared/themes/${themeId}.css`;
      }
      currentTheme = themeId;
      updateThemeSelectionUI(themeId);

      // Broadcast to portlet
      broadcastThemeToPortlet(themeId);

      // Persist to server
      const surface = getCurrentSurface();
      try {
        const response = await fetch('/api/preferences', {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          credentials: 'include',
          body: JSON.stringify({ surface, theme: themeId }),
        });
        if (!response.ok) {
          console.error('Failed to save theme preference');
        }
      } catch (err) {
        console.error('Failed to save theme preference:', err);
      }
    }

    /**
     * Load theme preference from API.
     * Shows theme picker only if user is authenticated.
     * Returns true if authenticated and theme loaded, false otherwise.
     */
    async function loadThemePreference() {
      const surface = getCurrentSurface();
      try {
        const response = await fetch(`/api/preferences?surface=${surface}`, {
          credentials: 'include',
        });
        if (response.ok) {
          const data = await response.json();
          if (data.theme && VALID_THEMES.includes(data.theme)) {
            currentTheme = data.theme;
            if (themeStylesheet) {
              themeStylesheet.href = `/shared/themes/${data.theme}.css`;
            }
            updateThemeSelectionUI(data.theme);
            broadcastThemeToPortlet(data.theme);
          }
          // User is authenticated - show theme picker
          if (themePicker) {
            themePicker.classList.remove('hidden');
          }
          return true;
        }
        // 401 or other error - user not authenticated, keep picker hidden
        return false;
      } catch (err) {
        console.error('Failed to load theme preference:', err);
        return false;
      }
    }

    /**
     * Broadcast theme change to portlet iframe
     */
    function broadcastThemeToPortlet(themeId) {
      if (moduleFrame && moduleFrame.contentWindow) {
        moduleFrame.contentWindow.postMessage({
          type: 'shell:theme',
          theme: themeId
        }, window.location.origin);
      }
    }

    // Theme picker button click
    if (themePickerBtn) {
      themePickerBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleThemeDropdown();
      });
    }

    // Theme item click handlers
    if (themePickerDropdown) {
      themePickerDropdown.querySelectorAll('.theme-picker-item').forEach(item => {
        item.addEventListener('click', async () => {
          const themeId = item.dataset.theme;
          if (VALID_THEMES.includes(themeId)) {
            closeThemeDropdown();
            try {
              await setTheme(themeId);
            } catch (err) {
              console.error('Theme switch failed:', err);
            }
          }
        });
      });
    }

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.theme-picker')) {
        closeThemeDropdown();
      }
    });

    // Initialize
    (async function init() {
      initHistoryState();
      loadTags();
      startDraftPolling();
      await loadThemePreference();
      updateThemeSelectionUI(currentTheme);
    })();
  </script>
</body>
</html>
