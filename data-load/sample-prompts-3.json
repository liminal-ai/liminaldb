{
	"prompts": [
		{
			"slug": "react-component-generator",
			"name": "React Component Generator",
			"description": "Generate React components with TypeScript",
			"content": "Create a React component:\n\nName: {{name}}\nProps: {{props}}\nBehavior: {{behavior}}\n\n```tsx\nimport { useState, useCallback } from 'react';\n\ninterface {{name}}Props {\n  // Define props here\n}\n\nexport function {{name}}({ ...props }: {{name}}Props) {\n  // Implementation\n  return (\n    <div>\n      {/* JSX */}\n    </div>\n  );\n}\n```\n\nInclude:\n- TypeScript interfaces\n- Proper hooks usage\n- Accessible markup\n- Unit test example",
			"tags": ["snippet", "code", "design"]
		},
		{
			"slug": "accessibility-audit",
			"name": "Accessibility Audit",
			"description": "Audit UI for WCAG compliance",
			"content": "Audit this UI for accessibility:\n\n{{component}}\n\nCheck against WCAG 2.1 AA:\n\n**Perceivable**\n- [ ] Alt text for images\n- [ ] Captions for video\n- [ ] Sufficient color contrast (4.5:1)\n\n**Operable**\n- [ ] Keyboard navigable\n- [ ] Focus indicators visible\n- [ ] No keyboard traps\n\n**Understandable**\n- [ ] Clear labels\n- [ ] Error messages helpful\n- [ ] Consistent navigation\n\n**Robust**\n- [ ] Valid HTML\n- [ ] ARIA used correctly\n\nFor each issue: severity, location, fix, code example.",
			"tags": ["instruction", "design", "review"]
		},
		{
			"slug": "customer-response-writer",
			"name": "Customer Response Writer",
			"description": "Write empathetic customer support responses",
			"content": "Write a response to this customer:\n\n{{message}}\n\nContext: {{context}}\nOutcome: {{resolution}}\n\nStructure:\n1. Acknowledge their frustration (don't dismiss)\n2. Explain what happened (briefly, no jargon)\n3. State what we're doing to fix it\n4. Offer compensation if appropriate\n5. Provide next steps\n\nTone: Professional, empathetic, solution-focused\nAvoid: Blame, excuses, corporate speak",
			"tags": ["instruction", "communication", "writing"]
		},
		{
			"slug": "dockerfile-generator",
			"name": "Dockerfile Generator",
			"description": "Generate optimized multi-stage Dockerfiles",
			"content": "Create a Dockerfile for:\n\nLanguage: {{language}}\nFramework: {{framework}}\nBuild command: {{build}}\nRun command: {{run}}\n\nOptimize for:\n- Small image size (multi-stage build)\n- Layer caching (dependencies before code)\n- Security (non-root user, minimal base)\n- Build reproducibility\n\n```dockerfile\n# Build stage\nFROM node:20-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci\nCOPY . .\nRUN npm run build\n\n# Production stage\nFROM node:20-alpine\nWORKDIR /app\nRUN addgroup -g 1001 -S app && adduser -S app -u 1001\nCOPY --from=builder /app/dist ./dist\nUSER app\nCMD [\"node\", \"dist/index.js\"]\n```",
			"tags": ["snippet", "code", "workflow"]
		},
		{
			"slug": "api-versioning-strategy",
			"name": "API Versioning Strategy",
			"description": "Design API versioning approach",
			"content": "Design versioning for this API:\n\n{{api_description}}\n\nConsider:\n1. **URL path**: `/v1/users` vs `/v2/users`\n2. **Header**: `Accept: application/vnd.api+json;version=1`\n3. **Query param**: `/users?version=1`\n\nFor each approach:\n- Pros/cons\n- Implementation complexity\n- Client impact\n- Caching implications\n\nRecommend one approach with rationale.\n\nAlso address:\n- Deprecation policy\n- Breaking vs non-breaking changes\n- Version sunset timeline",
			"tags": ["reference", "design", "planning"]
		},
		{
			"slug": "graphql-schema-designer",
			"name": "GraphQL Schema Designer",
			"description": "Design GraphQL schemas with best practices",
			"content": "Design a GraphQL schema for: {{domain}}\n\nEntities:\n{{entities}}\n\nFollow conventions:\n- Nullable by default, use `!` intentionally\n- Connections for pagination (Relay-style)\n- Input types for mutations\n- Descriptive field names\n\n```graphql\ntype Query {\n  user(id: ID!): User\n  users(first: Int, after: String): UserConnection!\n}\n\ntype Mutation {\n  createUser(input: CreateUserInput!): CreateUserPayload!\n}\n\ntype User {\n  id: ID!\n  email: String!\n  # Add fields\n}\n```\n\nInclude resolver hints for complex fields.",
			"tags": ["snippet", "code", "data", "design"]
		},
		{
			"slug": "rate-limit-designer",
			"name": "Rate Limiting Design",
			"description": "Design rate limiting strategy",
			"content": "Design rate limiting for: {{api}}\n\nTraffic patterns:\n{{patterns}}\n\nAlgorithms to consider:\n- **Fixed window**: Simple, but thundering herd at boundaries\n- **Sliding window**: Smoother, more complex\n- **Token bucket**: Allows bursts, configurable\n- **Leaky bucket**: Smooths traffic\n\nDefine:\n- Limits per tier (free/paid/enterprise)\n- Headers to return (X-RateLimit-*)\n- Response when limited (429 + Retry-After)\n- Distributed coordination (Redis, etc.)\n\nProvide implementation pseudocode.",
			"tags": ["instruction", "design", "code"]
		},
		{
			"slug": "caching-strategy",
			"name": "Caching Strategy Designer",
			"description": "Design multi-layer caching strategy",
			"content": "Design caching for: {{system}}\n\nAccess patterns:\n{{patterns}}\n\nLayers to consider:\n1. **Browser**: Cache-Control, ETags\n2. **CDN**: Edge caching for static assets\n3. **Application**: In-memory (LRU)\n4. **Distributed**: Redis/Memcached\n5. **Database**: Query cache\n\nFor each cached item define:\n- TTL (and why)\n- Invalidation strategy\n- Cache key structure\n- Stale-while-revalidate behavior\n\nAddress:\n- Cache stampede prevention\n- Consistency requirements\n- Monitoring/observability",
			"tags": ["instruction", "design", "analysis"]
		},
		{
			"slug": "env-config-template",
			"name": "Environment Configuration Template",
			"description": "Standardized environment configuration",
			"content": "```bash\n# Application\nNODE_ENV=development\nPORT=3000\nLOG_LEVEL=debug\n\n# Database\nDATABASE_URL=postgresql://user:pass@localhost:5432/db\nDATABASE_POOL_SIZE=10\n\n# Redis\nREDIS_URL=redis://localhost:6379\n\n# Auth\nJWT_SECRET=change-in-production\nJWT_EXPIRES_IN=1h\n\n# External Services\nSTRIPE_SECRET_KEY=sk_test_...\nSENDGRID_API_KEY=SG...\n\n# Feature Flags\nFEATURE_NEW_CHECKOUT=false\n```\n\nPrinciples:\n- Never commit secrets\n- Use descriptive names\n- Group by service\n- Document valid values\n- Provide sensible defaults",
			"tags": ["snippet", "reference", "code"]
		},
		{
			"slug": "ci-cd-pipeline",
			"name": "CI/CD Pipeline Designer",
			"description": "Design CI/CD pipeline for quality and speed",
			"content": "Design CI/CD for: {{project}}\n\nRequirements:\n- {{requirements}}\n\nStages:\n```yaml\n# .github/workflows/ci.yml\nname: CI\non: [push, pull_request]\njobs:\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - run: npm ci\n      - run: npm run lint\n  \n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - run: npm test\n  \n  build:\n    needs: [lint, test]\n    steps:\n      - run: npm run build\n  \n  deploy:\n    needs: build\n    if: github.ref == 'refs/heads/main'\n    steps:\n      - run: ./deploy.sh\n```\n\nOptimize for:\n- Fast feedback (parallelize)\n- Caching (dependencies)\n- Security (secrets management)",
			"tags": ["workflow", "code", "design"]
		},
		{
			"slug": "oauth-flow-explainer",
			"name": "OAuth Flow Explainer",
			"description": "Explain OAuth 2.0 flows with diagrams",
			"content": "Explain the {{flow}} OAuth flow for: {{use_case}}\n\nFlows:\n- **Authorization Code**: Web apps with backend\n- **PKCE**: Mobile/SPA apps\n- **Client Credentials**: Server-to-server\n- **Device Code**: TVs, CLIs\n\nInclude:\n1. Sequence diagram (text-based)\n2. Step-by-step explanation\n3. Security considerations\n4. Token storage recommendations\n5. Refresh token handling\n\nCommon mistakes to avoid:\n- Storing tokens in localStorage\n- Not validating state parameter\n- Exposing client secrets",
			"tags": ["reference", "code", "explain"]
		},
		{
			"slug": "seo-content-optimizer",
			"name": "SEO Content Optimizer",
			"description": "Optimize content for search engines",
			"content": "Optimize this content for SEO:\n\n{{content}}\n\nTarget keyword: {{keyword}}\n\nCheck:\n1. **Title**: Under 60 chars, keyword near start\n2. **Meta description**: 150-160 chars, compelling CTA\n3. **Headings**: H1 once, H2-H6 hierarchy\n4. **Keyword density**: 1-2%, natural usage\n5. **Internal links**: Relevant cross-references\n6. **Alt text**: Descriptive, include keyword if natural\n\nProvide:\n- Suggested title tag\n- Meta description\n- Heading structure\n- Content improvements\n- Schema markup if applicable",
			"tags": ["instruction", "writing", "transform"]
		},
		{
			"slug": "websocket-handler",
			"name": "WebSocket Handler Pattern",
			"description": "Robust WebSocket connection handling",
			"content": "```typescript\nclass WebSocketManager {\n  private ws: WebSocket | null = null;\n  private reconnectAttempts = 0;\n  private maxReconnects = 5;\n  private reconnectDelay = 1000;\n\n  connect(url: string) {\n    this.ws = new WebSocket(url);\n    \n    this.ws.onopen = () => {\n      console.log('Connected');\n      this.reconnectAttempts = 0;\n    };\n    \n    this.ws.onclose = (event) => {\n      if (!event.wasClean && this.reconnectAttempts < this.maxReconnects) {\n        setTimeout(() => {\n          this.reconnectAttempts++;\n          this.connect(url);\n        }, this.reconnectDelay * Math.pow(2, this.reconnectAttempts));\n      }\n    };\n    \n    this.ws.onmessage = (event) => {\n      const data = JSON.parse(event.data);\n      this.handleMessage(data);\n    };\n  }\n\n  private handleMessage(data: unknown) {\n    // Route messages by type\n  }\n\n  send(message: object) {\n    if (this.ws?.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify(message));\n    }\n  }\n}\n```",
			"tags": ["snippet", "code", "reference"]
		},
		{
			"slug": "feature-flag-system",
			"name": "Feature Flag Implementation",
			"description": "Design feature flag system",
			"content": "Design feature flags for: {{application}}\n\nFlag types:\n- **Boolean**: On/off\n- **Percentage**: Gradual rollout\n- **User segment**: Beta users, employees\n- **Environment**: Dev/staging/prod\n\n```typescript\ninterface FeatureFlags {\n  isEnabled(flag: string, context?: UserContext): boolean;\n  getVariant(flag: string, context?: UserContext): string;\n}\n\n// Usage\nif (flags.isEnabled('new-checkout', { userId: user.id })) {\n  return <NewCheckout />;\n}\n```\n\nConsider:\n- Default values (fail open vs closed)\n- Flag lifecycle (cleanup old flags)\n- A/B testing integration\n- Audit logging",
			"tags": ["reference", "code", "design"]
		},
		{
			"slug": "markdown-formatter",
			"name": "Markdown Formatter",
			"description": "Format and clean up markdown documents",
			"content": "Clean up this markdown:\n\n{{markdown}}\n\nFix:\n- Consistent heading levels (no skipping)\n- Proper list formatting\n- Code block language hints\n- Link formatting [text](url)\n- Table alignment\n- Remove trailing whitespace\n- Consistent blank lines\n\nAlso check:\n- Broken links\n- Missing alt text for images\n- Overly long lines (wrap at 80-100)",
			"tags": ["instruction", "writing", "transform"]
		},
		{
			"slug": "unit-test-patterns",
			"name": "Unit Test Patterns",
			"description": "Common unit testing patterns and examples",
			"content": "Write unit tests for:\n\n```{{language}}\n{{code}}\n```\n\nPatterns to use:\n\n**Arrange-Act-Assert**\n```typescript\ntest('should calculate total', () => {\n  // Arrange\n  const cart = new Cart();\n  cart.add({ price: 10, qty: 2 });\n  \n  // Act\n  const total = cart.getTotal();\n  \n  // Assert\n  expect(total).toBe(20);\n});\n```\n\n**Test doubles**\n- Stub: Returns canned data\n- Mock: Verifies interactions\n- Spy: Records calls\n\nCover:\n- Happy path\n- Edge cases\n- Error conditions",
			"tags": ["reference", "code", "explain"]
		},
		{
			"slug": "api-integration-guide",
			"name": "API Integration Guide",
			"description": "Step-by-step third-party API integration",
			"content": "Integrate with {{api_name}} API:\n\nDocumentation: {{docs_url}}\n\n## Authentication\n[How to get and use API keys]\n\n## Setup\n```typescript\nconst client = new ApiClient({\n  apiKey: process.env.API_KEY,\n  baseUrl: 'https://api.example.com/v1',\n});\n```\n\n## Common Operations\n\n### {{operation_1}}\n```typescript\nconst result = await client.doThing({ param: value });\n```\n\n### {{operation_2}}\n[Code example]\n\n## Error Handling\n[Common errors and how to handle]\n\n## Rate Limits\n[Limits and best practices]\n\n## Testing\n[How to test without hitting production]",
			"tags": ["workflow", "code", "explain"]
		},
		{
			"slug": "data-validation-schemas",
			"name": "Data Validation Schema",
			"description": "Create validation schemas with Zod",
			"content": "Create validation schemas for:\n\n{{data_description}}\n\n```typescript\nimport { z } from 'zod';\n\nexport const UserSchema = z.object({\n  id: z.string().uuid(),\n  email: z.string().email(),\n  name: z.string().min(1).max(100),\n  age: z.number().int().positive().optional(),\n  role: z.enum(['admin', 'user', 'guest']),\n  createdAt: z.coerce.date(),\n});\n\nexport type User = z.infer<typeof UserSchema>;\n\n// Validation\nconst result = UserSchema.safeParse(data);\nif (!result.success) {\n  console.error(result.error.flatten());\n}\n```\n\nInclude:\n- Nested objects\n- Arrays with item validation\n- Custom error messages\n- Transform/coerce where needed",
			"tags": ["snippet", "code", "data"]
		},
		{
			"slug": "incident-response-runbook",
			"name": "Incident Response Runbook",
			"description": "Step-by-step incident response procedure",
			"content": "## Runbook: {{incident_type}}\n\n**Severity**: {{severity}}\n**On-call team**: {{team}}\n\n### Detection\n- Alert name: {{alert}}\n- Dashboard: {{dashboard_link}}\n- Symptoms: {{symptoms}}\n\n### Immediate Actions\n1. Acknowledge the alert\n2. Check {{service}} status: `curl {{health_endpoint}}`\n3. Check recent deployments: `git log --oneline -5`\n4. Check logs: `{{log_command}}`\n\n### Diagnosis\n- If {{condition_1}}: Try {{action_1}}\n- If {{condition_2}}: Try {{action_2}}\n\n### Mitigation\n1. {{step_1}}\n2. {{step_2}}\n\n### Escalation\n- If unresolved after 15 min: Page {{escalation_contact}}\n\n### Post-Incident\n- Create postmortem doc\n- Schedule review meeting",
			"tags": ["workflow", "reference", "planning"]
		},
		{
			"slug": "code-translator",
			"name": "Code Translator",
			"description": "Translate code between programming languages",
			"content": "Translate this code from {{source_lang}} to {{target_lang}}:\n\n```{{source_lang}}\n{{code}}\n```\n\nGuidelines:\n- Use idiomatic {{target_lang}} patterns\n- Preserve functionality exactly\n- Handle language-specific differences:\n  - Type systems\n  - Error handling (exceptions vs Result)\n  - Async patterns\n  - Package/module systems\n\nProvide:\n1. Translated code\n2. Notes on any non-trivial translations\n3. Dependencies needed\n4. Gotchas in the target language",
			"tags": ["instruction", "code", "translate"]
		}
	]
}
